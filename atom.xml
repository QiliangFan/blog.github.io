<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Torch-Fan</title>
  
  <subtitle>学习笔记~</subtitle>
  <link href="https://www.torch-fan.site/atom.xml" rel="self"/>
  
  <link href="https://www.torch-fan.site/"/>
  <updated>2023-05-02T06:16:51.673Z</updated>
  <id>https://www.torch-fan.site/</id>
  
  <author>
    <name>Torch-Fan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核调试和Perf Tracing</title>
    <link href="https://www.torch-fan.site/2023/05/02/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%92%8CPerf-Tracing/"/>
    <id>https://www.torch-fan.site/2023/05/02/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%92%8CPerf-Tracing/</id>
    <published>2023-05-02T02:18:21.000Z</published>
    <updated>2023-05-02T06:16:51.673Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中…</p></blockquote><h1 id="1-内核调试"><a class="markdownIt-Anchor" href="#1-内核调试"></a> 1. 内核调试</h1><h2 id="11-systemtap"><a class="markdownIt-Anchor" href="#11-systemtap"></a> 1.1 <code>systemtap</code></h2><h3 id="111-相关资料"><a class="markdownIt-Anchor" href="#111-相关资料"></a> 1.1.1 相关资料：</h3><ul><li><a href="https://sourceware.org/systemtap/documentation.html">SystemTap Document</a></li><li><a href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/">SystemTap Beginners Guide</a></li><li><a href="https://sourceware.org/systemtap/tutorial/">SystemTap Tutorials</a></li></ul><h2 id="12-ftrace"><a class="markdownIt-Anchor" href="#12-ftrace"></a> 1.2 <code>ftrace</code></h2><h1 id="2-perf-tracing"><a class="markdownIt-Anchor" href="#2-perf-tracing"></a> 2. Perf Tracing</h1><h2 id="21-perf"><a class="markdownIt-Anchor" href="#21-perf"></a> 2.1 <code>perf</code></h2><h2 id="22-iostat"><a class="markdownIt-Anchor" href="#22-iostat"></a> 2.2 <code>iostat</code></h2><h2 id="23-top"><a class="markdownIt-Anchor" href="#23-top"></a> 2.3 <code>top</code></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;持续更新中…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-内核调试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-内核调试&quot;&gt;&lt;/a&gt; 1. 内核调试&lt;/h1&gt;
&lt;h2 id=&quot;11-systemtap&quot;</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    <category term="内核" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%86%85%E6%A0%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>内核源码-/include/net/inet_sock.h</title>
    <link href="https://www.torch-fan.site/2023/04/26/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81-include-net-inet-sock-h/"/>
    <id>https://www.torch-fan.site/2023/04/26/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81-include-net-inet-sock-h/</id>
    <published>2023-04-26T11:43:48.000Z</published>
    <updated>2023-05-02T06:55:59.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络序与字节序"><a class="markdownIt-Anchor" href="#1-网络序与字节序"></a> 1. 网络序与字节序：</h1><p><code>inet_sock.h</code>比较值得关注的内容是<code>inet_sock</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** struct inet_sock - representation of INET sockets</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @sk - ancestor class</span><br><span class="hljs-comment"> * @pinet6 - pointer to IPv6 control block</span><br><span class="hljs-comment"> * @inet_daddr - Foreign IPv4 addr</span><br><span class="hljs-comment"> * @inet_rcv_saddr - Bound local IPv4 addr</span><br><span class="hljs-comment"> * @inet_dport - Destination port</span><br><span class="hljs-comment"> * @inet_num - Local port</span><br><span class="hljs-comment"> * @inet_saddr - Sending source</span><br><span class="hljs-comment"> * @uc_ttl - Unicast TTL</span><br><span class="hljs-comment"> * @inet_sport - Source port</span><br><span class="hljs-comment"> * @inet_id - ID counter for DF pkts</span><br><span class="hljs-comment"> * @tos - TOS</span><br><span class="hljs-comment"> * @mc_ttl - Multicasting TTL</span><br><span class="hljs-comment"> * @is_icsk - is this an inet_connection_sock?</span><br><span class="hljs-comment"> * @uc_index - Unicast outgoing device index</span><br><span class="hljs-comment"> * @mc_index - Multicast device index</span><br><span class="hljs-comment"> * @mc_list - Group array</span><br><span class="hljs-comment"> * @cork - info to build ip hdr on each ip frag while socket is corked</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> &#123;</span><br><span class="hljs-comment">/* sk and pinet6 has to be the first two members of inet_sock */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span><span class="hljs-title">sk</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipv6_pinfo</span>*<span class="hljs-title">pinet6</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* Socket demultiplex comparisons on incoming packets. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inet_daddrsk.__sk_common.skc_daddr</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inet_rcv_saddrsk.__sk_common.skc_rcv_saddr</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inet_dportsk.__sk_common.skc_dport</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inet_numsk.__sk_common.skc_num</span><br><br>__be32inet_saddr;<br>__s16uc_ttl;<br>__u16cmsg_flags;<br>__be16inet_sport;<br>__u16inet_id;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_options_rcu</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">inet_opt</span>;</span><br><span class="hljs-type">int</span>rx_dst_ifindex;<br>__u8tos;<br>__u8min_ttl;<br>__u8mc_ttl;<br>__u8pmtudisc;<br>__u8recverr:<span class="hljs-number">1</span>,<br>is_icsk:<span class="hljs-number">1</span>,<br>freebind:<span class="hljs-number">1</span>,<br>hdrincl:<span class="hljs-number">1</span>,<br>mc_loop:<span class="hljs-number">1</span>,<br>transparent:<span class="hljs-number">1</span>,<br>mc_all:<span class="hljs-number">1</span>,<br>nodefrag:<span class="hljs-number">1</span>;<br>__u8bind_address_no_port:<span class="hljs-number">1</span>,<br>defer_connect:<span class="hljs-number">1</span>; <span class="hljs-comment">/* Indicates that fastopen_connect is set</span><br><span class="hljs-comment">  * and cookie exists so we defer connect</span><br><span class="hljs-comment">  * until first data frame is written</span><br><span class="hljs-comment">  */</span><br>__u8rcv_tos;<br>__u8convert_csum;<br><span class="hljs-type">int</span>uc_index;<br><span class="hljs-type">int</span>mc_index;<br>__be32mc_addr;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_mc_socklist</span> __<span class="hljs-title">rcu</span>*<span class="hljs-title">mc_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_cork_full</span><span class="hljs-title">cork</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  首先我们注意到有<code>inet_num</code>和<code>inet_sport</code>两个字段，并且前者表示Local Port，后者表示Source Port。那二者有何区别？这里StackOverflow上有一个相关回答：<a href="https://stackoverflow.com/questions/55313362/what-is-the-difference-between-local-port-and-source-port-in-inet-sock-h-in">https://stackoverflow.com/questions/55313362/what-is-the-difference-between-local-port-and-source-port-in-inet-sock-h-in</a></p><blockquote><p>其大意是：<code>inet_num</code>是<code>Local port in host byte-order / protocol type</code>，而<code>inet_sport</code>是<code>The source port in network byte-order. This is the port you see in packet.</code></p></blockquote><p>这就又涉及到一个网络字节序和主机字节序问题的讨论。这里有一篇相关博客：<a href="https://blog.csdn.net/lxj434368832/article/details/78499937">https://blog.csdn.net/lxj434368832/article/details/78499937</a>。</p><h2 id="11-网络字节序network-byte-order-nbo和主机字节序host-byte-order-hbo"><a class="markdownIt-Anchor" href="#11-网络字节序network-byte-order-nbo和主机字节序host-byte-order-hbo"></a> 1.1 网络字节序(Network Byte Order, NBO)和主机字节序(Host Byte Order, HBO)</h2><p>  <a href="https://linux.die.net/man/3/htonl">Linux man page</a>中提到，<code>arpa/inet.h</code>中定义了四个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span></span>;<br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span></span>;<br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span></span>;<br><span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span></span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>htonl</code></td><td style="text-align:center">将<code>uint32_t</code> 类型的<code>HBO地址</code>转为<code>NBO地址</code></td></tr><tr><td style="text-align:center"><code>htons</code></td><td style="text-align:center">将<code>uint16_t</code> 类型的<code>HBO地址</code>转为<code>NBO地址</code></td></tr><tr><td style="text-align:center"><code>ntohl</code></td><td style="text-align:center">将<code>uint32_t</code> 类型的<code>NBO地址</code>转为<code>HBO地址</code></td></tr><tr><td style="text-align:center"><code>ntohs</code></td><td style="text-align:center">将<code>uint16_t</code> 类型的<code>NBO地址</code>转为<code>HBO地址</code></td></tr></tbody></table><p>  Linux提供了相关的转换函数，了解NBO和HBO区别之前，我们再明确一下大端/小端的基本概念。沿着内存增大的方向，如果一个数据的的开始字节(一般也叫做Least Significant Byte, LSB最低有效字节)放在低地址，而结束字节(一般也叫做Most Significant Byte, MSB最高有效字节)放在高地址，则称这种数据存放方式为小端(little-endian)字节序，反之则称为大端(big-endian)字节序。简而言之：数据的初始字节放在低地址就是小端，放在高地址就是大端。具体如下图所述：</p><blockquote><p>注意：字节序只是字节的排列顺序不同，但对应的字节内部的8位二进制数顺序都是一样的~</p></blockquote><p><img src="byteorder.png" alt="字节序" /></p><p>   UDP/TCP/IP协议规定：把接收到的第一个字节当作高位字节看待。因此网络字节序统一都是大端字节序。而不同主机的字节序各有不同，为了保证网络通信时数据传输的一致性，就需要有NBO和HBO之间的相互转化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-网络序与字节序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-网络序与字节序&quot;&gt;&lt;/a&gt; 1. 网络序与字节序：&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;inet_sock.h&lt;/code&gt;比较值得关注的内容是&lt;code&gt;inet_sock</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    <category term="内核源码" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/"/>
    
    <category term="net" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/net/"/>
    
    
  </entry>
  
  <entry>
    <title>内核相关资料整理</title>
    <link href="https://www.torch-fan.site/2023/04/26/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    <id>https://www.torch-fan.site/2023/04/26/%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</id>
    <published>2023-04-26T05:29:21.000Z</published>
    <updated>2023-04-27T14:25:12.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面对eBPF进行了简单了解，但是eBPF使用kprobes和tracepoint时都需要引用到内核中的函数（如syscall）或者tracepoint。如果直接看内核源码未免难度过于高，因此作为一个eBPF或者内核新手，先对相关资料进行整理。【<font color="red"><strong>持续更新</strong></font>】</p></blockquote><h1 id="1-系统调用"><a class="markdownIt-Anchor" href="#1-系统调用"></a> 1. 系统调用：</h1><blockquote><p>注意，kprobe不只是能绑定在syscall上，几乎有所内核中的函数都能绑定~</p></blockquote><p>Linux的系统调用数量较多，已经有人整理了不同架构下的系统调用表（顺序靠前推荐度更高）：</p><ul><li><a href="https://x64.syscall.sh/">https://x64.syscall.sh/</a>: 64位操作系统下的系统调用，其他架构下的系统调用也提供了外链。</li><li><a href="https://filippo.io/linux-syscall-table/">https://filippo.io/linux-syscall-table/</a>: 只有64位系统的系统调用, 但是对于参数和寄存器给出的信息更为详细。</li></ul><h1 id="2-内核tracepoints"><a class="markdownIt-Anchor" href="#2-内核tracepoints"></a> 2. 内核Tracepoints：</h1><blockquote><p>相关文档:</p><ul><li><a href="https://www.kernel.org/doc/html/v4.19/trace/events.html">Linux event tracing</a></li></ul></blockquote><blockquote><p>目前内核tracepoint似乎还没有人进行总结汇总，但是可以通过指令来获取所有tp（需要root权限）：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /sys/kernel/debug/tracing/events/ -<span class="hljs-built_in">type</span> d<br></code></pre></td></tr></table></figure><p>上面的指令筛选指定目录下所有的目录，可见<code>/sys/kernel/debug/tracing/events/</code>下还有文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing/events/<br>find . -maxdepth 1 -<span class="hljs-built_in">type</span> f<br></code></pre></td></tr></table></figure><blockquote><p>输出:</p><p>./header_event</p><p>./header_page</p><p>./enable</p></blockquote><p>如果<code>cat enable</code>, 应该会得到输出<code>X</code>, 查阅tracepoint相关文档：<a href="https://www.kernel.org/doc/html/v4.19/trace/events.html">Linux event tracing</a>发现，这是控制tracepoint是否开启的标识。</p><p>再以tcp重传事件的tracepoint——<code>tcp_retransmit_skb</code>为例，如果要找到它只需:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 会输出 `/sys/kernel/debug/tracing/events/tcp/tcp_retransmit_skb`</span><br>find /sys/kernel/debug/tracing/events/ -<span class="hljs-built_in">type</span> d | grep tcp_retransmit<br><br><span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing/events/tcp/tcp_retransmit_skb<br><span class="hljs-built_in">ls</span> -lh<br></code></pre></td></tr></table></figure><p><img src="tracepoint_1.png" alt="每个Tracepoint目录下的内容" /></p><p>每个tracepoint下有6个文件，有的文件是控制是否启用，或者进行事件过滤（具体可参考文档）。</p><h1 id="3-内核源码文档"><a class="markdownIt-Anchor" href="#3-内核源码文档"></a> 3. 内核源码文档：</h1><blockquote><p>内核源码可以直接从Github上拉代码下来看，但是只是作为文档查询时，有个在线的文档还是比较省事：</p></blockquote><p>源码文档链接：<a href="https://elixir.bootlin.com/linux/v4.13/source/include">https://elixir.bootlin.com/linux/v4.13/source/include</a></p><h1 id="4-内核数据结构vmlinuxh"><a class="markdownIt-Anchor" href="#4-内核数据结构vmlinuxh"></a> 4. 内核数据结构：<code>vmlinux.h</code></h1><blockquote><p><code>vmlinux.h</code>是使用工具生成的代码文件，包含了系统的Linux内核源代码中使用的所有类型定义（比较大，大概有几MB）</p></blockquote><h1 id="内核tracing的相关文件路径小结"><a class="markdownIt-Anchor" href="#内核tracing的相关文件路径小结"></a> 内核tracing的相关文件路径小结：</h1><ol><li><code>bpf_trace_printk</code>打印的内容会输出到管道<code>/sys/kernel/debug/tracing/trace_pipe</code>中。</li><li><code>/sys/kernel/debug/tracing/events</code>包含了所有的tracepoint。(注意：<code>/sys/kernel/tracing/events</code>下也有tracepoint的内容，具体有何区别目前无法找到资料，但是仅推荐使用<code>/sys/kernel/debug/tracing/events</code>下的内容)</li><li><code>/sys/fs/bpf/</code>下包含了所有的ebpf pinned maps</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前面对eBPF进行了简单了解，但是eBPF使用kprobes和tracepoint时都需要引用到内核中的函数（如syscall）或者tracepoint。如果直接看内核源码未免难度过于高，因此作为一个eBPF或者内核新手，先对相关资料进行整理。【&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    <category term="内核" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%86%85%E6%A0%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>项目问题:文件描述符限制</title>
    <link href="https://www.torch-fan.site/2023/04/17/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6/"/>
    <id>https://www.torch-fan.site/2023/04/17/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6/</id>
    <published>2023-04-17T01:35:37.000Z</published>
    <updated>2023-04-21T03:20:53.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a class="markdownIt-Anchor" href="#1-背景"></a> 1. 背景：</h1><p>项目需要搭建ElasticSearch、Logstash、Filebeat、Kibana、Prometheus等工具进行微服务系统的性能监控，此外我们额外构建了一个后台，从ElasticSearch中读取保存的监控数据，绘制到前端页面中。整套微服务系统和检测工具都部署在minikube单机集群中，而前后端系统开发过程中使用另一台主机，后端要想访问单机集群中的ES数据库，需要对ES数据库暴露的接口进行端口转发:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl port-forward svc/elasticsearch-master -n observe --address 10.10.1.202 9200:9200<br></code></pre></td></tr></table></figure><h1 id="2-问题"><a class="markdownIt-Anchor" href="#2-问题"></a> 2. 问题:</h1><p>后端在获取ES数据时，当连接次数过多后，会出现如下错误：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E0225</span> <span class="hljs-number">15</span>:<span class="hljs-number">22</span>:<span class="hljs-number">30</span>.<span class="hljs-number">454203</span>   <span class="hljs-number">26392</span> portforward.go:<span class="hljs-number">353</span>] error creating forwarding stream for port <span class="hljs-number">9090</span> -&gt; <span class="hljs-number">9090</span>: Timeout occured<br></code></pre></td></tr></table></figure><p>并且kubectl的端口转发不会退出，在后端角度就是连数据库时会不断地中断连接。</p><h1 id="3-问题根因"><a class="markdownIt-Anchor" href="#3-问题根因"></a> 3. 问题根因：</h1><p>通过查找相关资料：<a href="https://github.com/kubernetes/kubernetes/issues/74551#issuecomment-881761717">https://github.com/kubernetes/kubernetes/issues/74551#issuecomment-881761717</a></p><p>有人提供了一种受到大家认可的思路：<code>进程可以打开的文件描述符数量限制了kubectl在端口转发时创建新的TCP连接</code></p><p>临时修改进程的文件描述符数量限制(number of file descriptor, <code>nofile</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -n 1048576<br></code></pre></td></tr></table></figure><p>也可以将修改写入配置文件中进行持久化: <code>sudo vim /etc/security/limits.conf</code>。添加下面这行:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>soft nofile 1048576<br></code></pre></td></tr></table></figure><blockquote><p>也可以将<code>ulimit -n 1048576</code>写入<code>/etc/profile</code>中，然后<code>source /etc/profile</code>使其立即生效</p></blockquote><p>通过调大nofile，确实能够延缓该问题。但是最终仍然还会出现该错误，似乎kubectl进行端口转发时不会及时释放老的连接。因此最终只能通过编写bash脚本和使用crontab来每天重启一次kubectl的port-forward。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>pid=$(ps -aux|grep -w <span class="hljs-string">&#x27;kubectl port-forward svc/elasticsearch-master -n observe --address 10.10.1.202 9200:9200&#x27;</span>|grep -v <span class="hljs-string">&#x27;grep&#x27;</span>|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>);<br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$pid</span>&quot;</span> ] ; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Found process:&quot;</span> <span class="hljs-variable">$pid</span><br>        <span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$pid</span><br><span class="hljs-keyword">fi</span><br><br>kubectl port-forward svc/elasticsearch-master -n observe --address 10.10.1.202 9200:9200<br></code></pre></td></tr></table></figure><p>使用crontab时还有个小细节，<code>kubectl</code>并不是/bin目录下的可执行文件，其路径是通过环境变量进行添加的，如果直接编写crontab文件该bash脚本不能完全正常执行，需要这样:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">SHELL=<span class="hljs-regexp">/bin/</span>bash<br>PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>:<span class="hljs-regexp">/sbin:/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:<span class="hljs-regexp">/usr/</span>bin<br>LANG=en_US.UTF-<span class="hljs-number">8</span><br><span class="hljs-number">5</span> *<span class="hljs-regexp">/4 * * * bash /</span>home<span class="hljs-regexp">/fanqiliang/</span>scripts/kubectl.sh<br><span class="hljs-number">5</span> *<span class="hljs-regexp">/4 * * * bash /</span>home<span class="hljs-regexp">/fanqiliang/</span>scripts/kubectl_prometheus.sh<br><span class="hljs-number">5</span> *<span class="hljs-regexp">/4 * * * bash /</span>home<span class="hljs-regexp">/fanqiliang/</span>scripts/kubectl_kibana.sh<br><span class="hljs-number">5</span> *<span class="hljs-regexp">/4 * * * bash /</span>home<span class="hljs-regexp">/fanqiliang/</span>scripts/kubectl_chaosmesh.sh<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-背景&quot;&gt;&lt;/a&gt; 1. 背景：&lt;/h1&gt;
&lt;p&gt;项目需要搭建ElasticSearch、Logstash、Filebeat、Kibana、Prometheus等工具进行微服务系</summary>
      
    
    
    
    <category term="项目总结" scheme="https://www.torch-fan.site/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    <category term="遇到的问题" scheme="https://www.torch-fan.site/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 进程调试</title>
    <link href="https://www.torch-fan.site/2023/04/13/Linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>https://www.torch-fan.site/2023/04/13/Linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95/</id>
    <published>2023-04-13T10:25:39.000Z</published>
    <updated>2023-04-14T07:43:10.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-linux进程的core-dump机制"><a class="markdownIt-Anchor" href="#1-linux进程的core-dump机制"></a> 1. Linux进程的Core Dump机制</h1><blockquote><p>当Linux进程在运行过程中出现异常终止或崩溃，系统会将程序当时的状态记录下来，保存在一个core文件中，这种机制称为<code>Core Dump</code>，又叫&quot;<font color='red'><strong>核心转储</strong></font>&quot;。core文件中包含了程序异常时的内存数据、寄存器以及运行堆栈等信息，开发人员可以使用调试工具来快速定位程序异常原因。</p></blockquote><blockquote><p>顺便说一句，在Linux中如果想看一个运行中进程的堆栈信息，可以查看<code>/proc/&lt;pid&gt;/stack</code>文件的内容，如果一个进程hang住了，就可以大致确定范围。</p></blockquote><p>Linux中对core文件的大小是具有一定限制的，<code>ulimit -c</code>是专门用来控制生成的core文件大小限制的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看Linux core文件的大小限制(如果为0的话表示不生成core文件)</span><br><span class="hljs-built_in">ulimit</span> -c<br><span class="hljs-comment"># 设置Linux core文件的大小</span><br><span class="hljs-built_in">ulimit</span> -c &lt;file-size&gt;<br><span class="hljs-built_in">ulimit</span> -c 1024 <span class="hljs-comment"># 1024k的小小限制</span><br><span class="hljs-comment"># 不限制Linux core文件的大小</span><br><span class="hljs-built_in">ulimit</span> -c unlimited<br></code></pre></td></tr></table></figure><p>上面对Linux core文件大小限制的修改只是临时的，如果要将修改持久化需要写入配置文件里，这里有两种方式：</p><ol><li>在<code>/etc/profile</code>中添加<code>ulimit -c unlimited</code>，如果要让改变立即生效，可以<code>source /etc/profile</code></li><li>修改<code>/etc/security/limits.conf</code>中：<code>#* soft core 0</code>取消注释后并改为<code>* soft core unlimited</code></li></ol><blockquote><p>注意，ulimit的限制有<code>soft</code>和<code>hard</code>之分，<code>soft</code>限制只是一种参考，超过该限制会警告，而<code>hard</code>限制则是强制的限制了。</p></blockquote><p><font color="red">注意</font>：默认情况下，Linux的core文件限制为0，即不生成core文件。同时，当core文件限制太小时，生成的core文件可能被截断（可能导致无法正常调试）。一般core文件大小要比进程所占用的内存要大一些。</p><h1 id="2-core文件的名称和生成路径"><a class="markdownIt-Anchor" href="#2-core文件的名称和生成路径"></a> 2. core文件的名称和生成路径</h1><blockquote><p>默认生成路径: 输入可执行文件运行命令的同一路径下<br />默认生成名字: 默认命名为core，新的core文件会覆盖旧的core文件</p></blockquote><h2 id="21-设置pid作为文件扩展名"><a class="markdownIt-Anchor" href="#21-设置pid作为文件扩展名"></a> 2.1 设置pid作为文件扩展名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> | sudo <span class="hljs-built_in">tee</span> /proc/sys/kernel/core_uses_pid<br></code></pre></td></tr></table></figure><p>或者使用命令行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systcl -w kernel.core_uses_pid=1<br></code></pre></td></tr></table></figure><h2 id="22-修改core文件的保存位置"><a class="markdownIt-Anchor" href="#22-修改core文件的保存位置"></a> 2.2 修改core文件的保存位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -w kernel.core_pattern=/home/user/core_dir/core-%e-%p-%t<br></code></pre></td></tr></table></figure><p>上面这个指令将所有的core文件同一保存在一个路径中，并且包含额外信息，格式化字符的含义如下：</p><table><thead><tr><th style="text-align:center">格式化字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">%p</td><td style="text-align:center">pid</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">uid</td></tr><tr><td style="text-align:center">%g</td><td style="text-align:center">gid</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">the <code>signal</code> that caused the coredump into the filename</td></tr><tr><td style="text-align:center">%t</td><td style="text-align:center">the <code>UNIX</code> time that the coredump occurred into filename</td></tr><tr><td style="text-align:center">%h</td><td style="text-align:center">hostname</td></tr><tr><td style="text-align:center">%e</td><td style="text-align:center">the coredumping <code>executable name</code></td></tr></tbody></table><h2 id="23-永久修改"><a class="markdownIt-Anchor" href="#23-永久修改"></a> 2.3 永久修改</h2><p>修改<code>/etc/sysctl.conf</code>配置文件，添加如下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kernel.core_uses_pid = 1<br>kernel.core_pattern = /home/user/core_dir/core-%e-%p-%t<br></code></pre></td></tr></table></figure><p>随后执行命令立即生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sysctl -p  <span class="hljs-comment"># load values from configuration file</span><br></code></pre></td></tr></table></figure><p>这时<code>/proc/sys/kernel/core_pattern</code>的值应该为之前设定的路径。</p><h1 id="3-对coredump生成的文件进行调试"><a class="markdownIt-Anchor" href="#3-对coredump生成的文件进行调试"></a> 3. 对coredump生成的文件进行调试:</h1><p>使用GDB调试一个程序，只需要二进制文件和相应的debug symbols（g++编译时可以通过-g参数将这些符号编译进二进制文件中）。而core文件包含相应程序崩溃时的堆栈信息。如果想要知道一个文件具体是不是core文件，可以：<code>readelf -h &lt;file&gt;</code>,<code>-h</code>参数是指定只显示file header部分，其中会包含文件类型的说明。</p><blockquote><p><font color="red"><strong>注意</strong></font>：如果二进制文件在编译时没有加上-g参数，那么后续调试时将只能看到调用信息，而无法通过<code>list</code>指令看到每个函数的代码。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 调试程序在崩溃时的堆栈状态：</span><br>gdb &lt;binary_file_path&gt; &lt;core_file_path&gt;<br></code></pre></td></tr></table></figure><p>当进入gdb交互终端时，可以用<code>bt</code>(<code>backtrace</code>的简写)来获取当前（程序崩溃时）的调用栈情况。在调用栈中，每个函数调用都包含一个对应的序号，可以用<code>frame &lt;number&gt;</code>来跳到指定的函数栈中。</p><p>当我们进入目标函数调用栈中后，就可以查看变量的值。使用<code>info locals</code>来看有哪些局部变量，使用<code>print &lt;variable&gt;</code>来打印某个变量的值。</p><p>gdb的指令非常多，如果不是一天到晚都在调试程序的话，指令还是很容易忘的，特别对于学生而言，很多时候学习gdb只是了解其可能的用途，很少在日常中频繁去使用，因此可以使用<code>help</code>指令来获取一些帮助信息。</p><h1 id="4-实际例子"><a class="markdownIt-Anchor" href="#4-实际例子"></a> 4. 实际例子：</h1><p>首先我们写一个会coredump的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">call_vec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>*&gt; arr)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *arr[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>*&gt; a;<br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<br>    cout &lt;&lt; <span class="hljs-built_in">call_vec</span>(a) &lt;&lt; endl;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了能在调试时看到源码，加上<code>-g</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g test.cpp -o <span class="hljs-built_in">test</span><br>./test<br></code></pre></td></tr></table></figure><p>随后对其进行调试：<code>gdb ./test ./core.1997745</code></p><p><img src="gdb1.png" alt="进入调试" /></p><p>接下来可以切换调用栈中的函数，并打印局部变量或者参数等信息：</p><blockquote><p>注：源码、变量等信息需要debug symbols才能看到，如果没有的话就只能看调用了哪些函数了。</p></blockquote><p><img src="gdb2.png" alt="开始调试" /></p><p>细心的话可以看到，当调用<code>bt</code>获取函数调用栈信息时，会给出是从函数哪一行进入下一层（或者崩溃）的。当使用<code>frame &lt;num&gt;</code>切换栈帧时，也会顺便打印一下是从哪一行进入下一层或崩溃的。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料:</h1><p>[1]: <a href="https://blog.csdn.net/anyegongjuezjd/article/details/107146541">https://blog.csdn.net/anyegongjuezjd/article/details/107146541</a><br />[2]: <a href="https://stackoverflow.com/questions/5115613/core-dump-file-analysis">https://stackoverflow.com/questions/5115613/core-dump-file-analysis</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-linux进程的core-dump机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-linux进程的core-dump机制&quot;&gt;&lt;/a&gt; 1. Linux进程的Core Dump机制&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;当</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>(二)eBPF的Hello World</title>
    <link href="https://www.torch-fan.site/2023/04/11/eBPF%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.torch-fan.site/2023/04/11/eBPF%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-11T11:10:15.000Z</published>
    <updated>2023-04-27T13:31:53.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-准备工作"><a class="markdownIt-Anchor" href="#1-准备工作"></a> 1. 准备工作</h1><blockquote><p>这一章的主要内容是用eBPF写一个Hellow World程序，因此就需要开始一些简单的环境搭建工作，作为后续深入的准备。</p></blockquote><p>首先为了更好的上手eBPF，我们从<a href="https://github.com/iovisor/bcc">BCC(BPF Compiler Collection)</a>入手，这个工具提供了eBPF的Python Binding。</p><p>安装方式可以参考仓库中给出的<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">指南</a>，注意，目前只推荐通过源码的方式进行安装。</p><h1 id="2-hello-world"><a class="markdownIt-Anchor" href="#2-hello-world"></a> 2. Hello World</h1><p>首先，我们知道<code>fork</code>会调用<code>sys_clone</code>这个系统调用，因此我们可以编写如下程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br><span class="hljs-comment"># 这个ebpf程序会绑定在sys_clone这个系统调用上（fork所使用的）</span><br>BPF(text=<span class="hljs-string">&#x27;int kprobe__sys_clone(void *ctx) &#123; bpf_trace_printk(&quot;Hello, World!\\n&quot;); return 0; &#125;&#x27;</span>).trace_print()<br></code></pre></td></tr></table></figure><p><code>kprobe__sys_clone</code>表示绑定内核态函数sys_clone，每当其触发时，就执行<code>kprobe__sys_clone</code>的内容。其中<code>bpf_trace_printk()</code>打印的内核信息会出现在:<code>/sys/kernel/debug/tracing/trace_pipe</code>中。该文件内容的查看需要root权限。</p><p>随后我们可以在命令行执行这个python脚本(注意，我们需要root权限): <code>sudo python3 main.py</code></p><p>但是存在一个问题是：有时我们知道一个用户态程序，不知道其对应的系统调用是什么，却想用kprobe绑定其在内核态函数执行的事件。eBPF提供了相应的辅助函数(helper function): <code>get_syscall_fnname</code>。具体用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Hello World!&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 创建一个待绑定的函数 hello，后面我们会将它绑定到一个内核函数的执行上</span><br>b = BPF(text=program)<br><br><span class="hljs-comment"># 调用helper function获取函数名对应的系统调用</span><br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br><span class="hljs-comment"># 进行kprobe绑定</span><br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment"># 打印eBPF程序的执行情况</span><br>b.trace_print()<br></code></pre></td></tr></table></figure><p>这一个例子中，我们又看到不一样的绑定方式，第一种方式是通过定义一个具有特别名字的用户态程序来实现对相应syscall的自动绑定，第二种方式需要我们主动调用attach函数进行绑定。</p><p>另一方面我们注意到，eBPF程序可以通过一个trace pipe输出相应信息，可以作为最基本的调试目的。但是由于只能输出纯文本，其信息丰富度有限，无法表示结构化数据。特别是当有数量较多的eBPF同时向trace pipe中输出信息，那么信息将变得混乱不堪。</p><h1 id="3-bpf-maps"><a class="markdownIt-Anchor" href="#3-bpf-maps"></a> 3. BPF Maps</h1><p><code>map</code>是一个能够被eBPF程序访问的数据结构，且内核态和用户态下都能访问。<code>map</code>是eBPF有别于其前身的重要变化，但是<code>eBPF maps</code>和<code>BPF maps</code>都有人使用。<code>map</code>主要有两点用途:</p><ol><li>用于在多个eBPF程序之间共享数据</li><li>用于eBPF(运行在内核的那部分代码)与用户态应用程序之间进行通信</li></ol><p>而<code>map</code>典型的使用方式包含以下三点:</p><ol><li>在用户态下编写一些配置信息，以供eBPF程序使用</li><li>某个eBPF程序向其中存储一些状态，然后供另一个eBPF程序使用（或者在将来供同一个eBPF读取，做一些状态恢复的工作）</li><li>eBPF程序可以将一些结果或者指标写进<code>map</code>, 提供给其他用户态应用程序来展示结果。</li></ol><p><code>BPF maps</code>的各种具体类型定义在Linux的<code>uapi/linux/bpf.h</code>中，并且<a href="https://docs.kernel.org/bpf/maps.html">内核文档</a>中也包含相关的类型信息。通常里面的数据都是使用key-value的形式存储。这一章中，书中介绍了三种类型的<code>maps</code>：<code>hash tables</code>, <code>perf and ring buffers</code>, 和<code>arrays</code>。</p><p>除此以外，还有一些针对特定操作优化的<code>map</code>类型，譬如: <code>first-in-first-out queues</code>, <code>first-in-last-out stacks</code>, <code>least-recently-used data storage</code>, <code>longest-prefix matching</code>, 和<code>Bloom filters</code>(一种专门用来快速判断元素是否存在的数据集)。</p><p>而有一些<code>map</code>类型则具有特定的作用。譬如<code>sockmaps</code>和<code>devmaps</code>保存着关于sockets和network devices的信息，并且被网络相关的eBPF程序用于进行<code>流量重定向(redirect traffic)</code>。<code>program array map</code>存储着一系列被索引的eBPF程序，这个结构用来实现<code>尾调用(tail calls)</code>——一个eBPF程序调用另一个eBPF程序。甚至还有<code>map-of-maps</code>的类型用来实现maps信息的存储。</p><p>当一些<code>map</code>可能同时被多个cpu并发访问时，就涉及到竞态问题。Linux内核版本5.1之后为一些<code>maps</code>支持了自旋锁(spin lock)，这一点将之后再补充。</p><h2 id="31-hash-table-map"><a class="markdownIt-Anchor" href="#31-hash-table-map"></a> 3.1 Hash Table Map</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_HASH(counter_table);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    u64 uid;</span><br><span class="hljs-string">    u64 counter = 0;</span><br><span class="hljs-string">    u64 *p;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    uid = bpf_get_current_uid_gid() &amp; 0xffffffff;</span><br><span class="hljs-string">    p = counter_table.lookup(&amp;uid);</span><br><span class="hljs-string">    if (p != 0) &#123;</span><br><span class="hljs-string">        counter = *p;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    counter++;</span><br><span class="hljs-string">    counter_table.update(&amp;uid, &amp;counter);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>bpf = BPF(text=program)<br>syscall = bpf.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>bpf.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><ol><li><p><code>BPF_HASH()</code>是BCC定义的宏，用来定义一个<code>hash table map</code>, 具体可见: <a href="https://android.googlesource.com/platform/external/bcc/+/refs/heads/android10-c2f2-s1-release/docs/reference_guide.md#2_bpf_hash">https://android.googlesource.com/platform/external/bcc/+/refs/heads/android10-c2f2-s1-release/docs/reference_guide.md#2_bpf_hash</a></p></li><li><p><code>bpf_get_current_uid_gid</code>是一个eBPF的helper function用来获取触发kprobe事件对应的进程的user ID。<font color="red"><strong>返回值的低32位是UID，高32位是UID</strong></font>，因此<code>bpf_get_current_uid_gid() &amp; 0xffffffff</code>作用是将低32位的uid取出来。</p></li><li><p><code>counter_table.lookup(&amp;uid)</code>是用来在hash table中查询一个键对应的值，返回值是对应value的地址。这里可能会想：<code>&amp;uid</code>并非正确的C语言用法，<font color="red"><strong>这是因为一个eBPF源码送到compiler进行编译之前，会对源程序进行修正并重写为正确的C语言代码，随后才会送进编译器中</strong></font>。<code>p=counter_table.lookup(&amp;uid)</code>也是同理，虽然看起来是错误的，但是编译时会自动修正。<font color="cyan">虽然为eBPF hash table map设置的键值类型是u64（默认类型），但是传参时为了高效都是以指针的形式传入——尽管传入的是函数局部变量，但是这点错误并不影响编译，反而是eBPF程序的推荐写法</font></p></li><li><p><code>counter_table.update(&amp;uid, &amp;counter);</code>是用来更新对应uid的计数信息。</p></li></ol><h3 id="311-在用户空间程序中访问ebpf-maps数据结构"><a class="markdownIt-Anchor" href="#311-在用户空间程序中访问ebpf-maps数据结构"></a> 3.1.1 在用户空间程序中访问eBPF maps数据结构：</h3><blockquote><p>上面我们定义了名为<code>counter_table</code>的<code>hash table map</code>。如果想在Python代码中获取对应数据结构的内容，可以这样：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        sleep(<span class="hljs-number">2</span>)<br>        s = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> bpf[<span class="hljs-string">&quot;counter_table&quot;</span>].items():<br>            s += <span class="hljs-string">f&quot;ID <span class="hljs-subst">&#123;k.value&#125;</span>: <span class="hljs-subst">&#123;v.value&#125;</span>\t&quot;</span><br>        <span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>bpf[“counter_table”]中存储的是键值对，键和值类型是一个对象(<code>c_ulong</code>)，如果要从中获取值只需要<code>k.value</code>即可转为传统的标量。要注意的是，以上面那种方式创建的<code>hash table map</code>并不能持久化，每次重启程序原先的状态就不存在了。并且这种map也不能在eBPF程序之间共享。</p><h3 id="312-持久化并共享ebpf-maps"><a class="markdownIt-Anchor" href="#312-持久化并共享ebpf-maps"></a> 3.1.2 持久化并共享eBPF maps:</h3><blockquote><p>此处可参阅文档：<a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#pinned-maps">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#pinned-maps</a></p><p><code>BPF_TABLE_PINNED(_table_type, _key_type, _leaf_type, _name, _max_entries, &quot;/sys/fs/bpf/xyz&quot;)</code>: 如果对应的map存在就获取，不存在则创建一个。<code>/sys/fs/bpf</code>是一个特别的bpffs。</p><p><font color="red">注意</font>，请务必确保bcc是通过源码编译安装的，否则无法确保是最新的~</p></blockquote><p>首先我们创建一个<code>pinned map</code>, 以供其他eBPF程序访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bcc<br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_TABLE_PINNED(&quot;hash&quot;, u64, u64, counter_table, 1024, &quot;/sys/fs/bpf/map&quot;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    u64 uid;</span><br><span class="hljs-string">    u64 counter = 0;</span><br><span class="hljs-string">    u64 *p;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    uid = bpf_get_current_uid_gid() &amp; 0xffffffff;</span><br><span class="hljs-string">    p = counter_table.lookup(&amp;uid);</span><br><span class="hljs-string">    if (p != 0) &#123;</span><br><span class="hljs-string">        counter = *p;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    counter++;</span><br><span class="hljs-string">    counter_table.update(&amp;uid, &amp;counter);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>bpf = BPF(text=program)<br>syscall = bpf.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>bpf.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-built_in">print</span>(bpf.get_table(<span class="hljs-string">&quot;counter_table&quot;</span>))<br></code></pre></td></tr></table></figure><p>接着在另一个程序中编写如下内容，即可获取相应<code>pinned map</code>，注意这个map即使在第一个程序退出之后仍然存在，且始终可以被任意eBPF访问到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_TABLE_PINNED(&quot;hash&quot;, u64, u64, counter_table, 1024, &quot;/sys/fs/bpf/map&quot;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void* ctx) &#123;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>bpf = BPF(text=program)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> bpf.get_table(<span class="hljs-string">&quot;counter_table&quot;</span>).items():<br>    <span class="hljs-built_in">print</span>(k.value, v.value)<br></code></pre></td></tr></table></figure><h2 id="32-perf-and-ring-buffer-maps"><a class="markdownIt-Anchor" href="#32-perf-and-ring-buffer-maps"></a> 3.2 Perf and Ring Buffer Maps</h2><blockquote><p>上面的例子中使用hash table map来在内核和用户态空间中交换数据，但是Linux内核支持使用perf buffers和其变种BPF ring buffers来完成这个数据交换的过程。注意，<code>BPF ring buffers</code>在<font color="red">Linux kernel 5.8</font>之后才支持，但是相比<code>BPF perf buffers</code>更受欢迎。关于如何使用<code>BPF ring buffers</code>来进行数据交换，将在后面章节详细给出例子。</p></blockquote><h3 id="321-ring-buffer"><a class="markdownIt-Anchor" href="#321-ring-buffer"></a> 3.2.1 Ring Buffer</h3><blockquote><p>Ring Buffer的机制其实细节还是非常多的，由于关注的是eBPF这里只能给出最粗略和感性的认知。</p></blockquote><p>  在eBPF中，Ring Buffer的概念并没有什么特别的。Ring Buffer就是一小块内存，逻辑上以&quot;环(ring)&quot;进行组织，包含两个指针: <code>写指针</code>和<code>读指针</code>。</p><p>  当进行数据写入时，无论当前写指针指向的内容是什么，会直接写入指定长度（长度信息包含在数据对象的header中）的数据，写指针会偏移到写入数据结尾的下一个位置，等待下一次写入。</p><p>  当进行数据读取时，也是直接从当前读指针处获取指定长度的数据，然后将读指针偏移指定长度（<font color="cyan">方向和写指针一致</font>）</p><p>  注意：</p><ol><li>当读指针和写指针重叠时，意味着&quot;没有&quot;数据需要去读了。</li><li>如果一个写操作，可能使写指针超过读指针(意味着写指针写满一&quot;圈&quot;数据了至少), 那么该写操作将被抛弃并且<code>drop counter</code>会自增1. <code>drop counter</code>用来记录自上一次成功读取数据后，是否有数据丢失。(<font color="red">注意：当发生数据覆盖时究竟是抛弃要写入的数据还是允许覆盖，这并不是一概而论的，有的场景中就比较宽松。</font>)</li><li>如果读操作和写操作的速率始终保持一致，那么就能使用ring buffer读取相当长的数据(并不存在数据丢失问题，写多少读多少)</li></ol><p><img src="ring_buffer.png" alt="Ring Buffer" /></p><h3 id="322-定义perf-buffer"><a class="markdownIt-Anchor" href="#322-定义perf-buffer"></a> 3.2.2 定义Perf Buffer:</h3><p>第一个程序将用来对Perf Buffer进行写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python">// 定义一个名为`output`的Perf Buffer Map<br>BPF_PERF_OUTPUT(output);<br><br>// 定义一个struct用来传送数据<br>struct data_t &#123;<br>    <span class="hljs-built_in">int</span> pid;<br>    <span class="hljs-built_in">int</span> uid;<br>    char command[<span class="hljs-number">16</span>];<br>    char message[<span class="hljs-number">12</span>];<br>&#125;;<br><br><span class="hljs-built_in">int</span> hello(void *ctx) &#123;<br>    struct data_t data = &#123;&#125;;<br>    char message[<span class="hljs-number">12</span>] = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br>    // tgid对应线程而言就是其所属进程的pid，对进程而言等价于pid<br>    data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="hljs-number">32</span>;<br>    data.uid = bpf_get_current_uid_gid() &amp; <span class="hljs-number">0xfffffff</span>;<br><br>    // 获取进程名字<br>    bpf_get_current_comm(&amp;data.command, sizeof(data.command));<br>    // 为了安全，内核内存的读取必须使用bpf_probe_read_kernel进行;<br>    bpf_probe_read_kernel(&amp;data.message, sizeof(data.message), message);<br><br>    // `ctx`是kprobes或kretprobes提供的;<br>    // `per_submit`会将自定义的data提交到user space中(最终会触发`bpf_perf_event_output`)<br>    output.perf_submit(ctx, &amp;data, sizeof(data));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>bpf = BPF(text=program)<br>syscall = bpf.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>bpf.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_event</span>(<span class="hljs-params">cpu, data, size</span>):<br>    <span class="hljs-comment"># 这是一种便捷的方式对传入的data对象进行解析(转为python对象)，具体可见：https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#2-open_perf_buffer </span><br>    data = b[<span class="hljs-string">&quot;output&quot;</span>].event(data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;data.pid&#125;</span> <span class="hljs-subst">&#123;data.uid&#125;</span> <span class="hljs-subst">&#123;data.command.decode()&#125;</span> <span class="hljs-subst">&#123;data.message.decode()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># BCC进行了封装，可以通过b[&quot;output&quot;]获取对应的Perf Buffer</span><br><span class="hljs-comment"># 为Perf Buffer的读取绑定一个回调函数对读取的数据进行处理:</span><br>b[<span class="hljs-string">&quot;output&quot;</span>].open_perf_buffer(print_event)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 对Perf Buffer的写入事件进行监听，一旦有数据写入就进行读取；触发回调函数`print_event`</span><br>    b.perf_buffer_poll()<br><br><span class="hljs-comment"># While True:</span><br><span class="hljs-comment">#   try:</span><br><span class="hljs-comment">#       b.perf_buffer_poll()</span><br><span class="hljs-comment">#   except KeyboardInterrupt:</span><br><span class="hljs-comment">#       exit()</span><br></code></pre></td></tr></table></figure><p>  注意，<code>Perf Buffer</code>也不是共享和持久的。如果要持久也得用pinned map。这里<code>hello</code>函数的参数是kprobes或者kretprobes提供的，并且还可以调用一些helper function，但<font color="pink"><strong>能够使用哪些上下文信息和能够调用哪些helper function取决于程序的类型和触发程序的事件是什么</strong></font>，在《Learning eBPF》的第七章，对这些进行了介绍。</p><h2 id="33-function-calls"><a class="markdownIt-Anchor" href="#33-function-calls"></a> 3.3 Function Calls</h2><p>  原本在eBPF程序中只能调用helper function，如果想要调用其他函数就必须将自定义函数声明为内联:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx, <span class="hljs-type">int</span> val)</span></span>;<br></code></pre></td></tr></table></figure><p>  内联函数和普通函数在汇编上的区别就是没有额外的跳跃指令，内联函数的函数体会在被调用的地方被原地扩展。但是<font color="red"><strong>从Linux内核版本4.16和LLVM 6.0之后</strong></font>，eBPF中只能使用内联函数的约束就被废除了。但是BCC仍然不支持“BPF subprograms”，仅支持内联函数。</p><h2 id="34-tail-calls"><a class="markdownIt-Anchor" href="#34-tail-calls"></a> 3.4 Tail Calls</h2><blockquote><p><a href="https://ebpf.io/">ebpf.io</a>中描述了: <code>tail calls can call and execute another eBPF program and replace the execution context, similar to how the execve() system call operates for regular process.</code> 简单来说，<font color="red"><strong>当tail call完成时，不会返回到调用者的上下文环境中</strong></font>。</p></blockquote><blockquote><p>Tail call并非eBPF编程中所独有的。tail call的通用目的是为了避免当函数递归调用时，栈帧无限地增加(这会导致栈溢出)。具体而言，可以重新编排函数代码，使得递归调用函数后，没有任何其他需要干的内容——即递归调用就是函数体的最后一行代码。这样，<code>tail call</code>允许一系列的函数调用不会增长栈的大小。毕竟，当递归调用时，上一个栈帧的函数体不再被需要了，可以被优化掉。在eBPF中，栈帧大小仅有512B。</p></blockquote><p>  Tail call通过helper function: <code>bpf_tail_call()</code>来使用，其函数签名如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">bpf_tail_call</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctx, <span class="hljs-keyword">struct</span> bpf_map *prog_array_map, u32 index)</span></span>;<br></code></pre></td></tr></table></figure><p>  参数含义如下:</p><ul><li><code>ctx</code>用来将当前eBPF程序的上下文传递给被调用的eBPF程序</li><li><code>prog_array_map</code>是一个eBPF map，类型为<code>BPF_MAP_TYPE_PROG_ARRAY</code>，包含了一系列的<em>文件描述符</em>，每个文件描述符都表示一个eBPF程序。</li><li><code>index</code>表示<code>prog_array_map</code>中哪个eBPF程序应该被调用。</li></ul><p>  这里存在两种情况：</p><ol><li>如果<code>bpf_tail_call</code>执行成功，对应的eBPF程序将会执行并替换当前栈帧(当前eBPF的函数体就不再被执行了)</li><li>如果<code>bpf_tail_call</code>执行失败，当前eBPF程序的函数体会继续执行</li></ol><p>下面是一个例子:</p><blockquote><p><code>sys_enter</code> tracepoint和kprobe都是一个触点，每当一个系统调用被执行完时，<code>sys_enter</code>这个tracepoint就会被触发。只需要将一个函数绑定到tracepoint上，每次tracepoint被触发时，该函数会被执行。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-keyword">import</span> ctypes <span class="hljs-keyword">as</span> ct<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">// 注册一个`BPF_MAP_TYPE_PROG_ARRAY`类型的bpf map</span><br><span class="hljs-string">BPF_PROG_ARRAY(syscall, 300);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(struct bpf_raw_tracepoint_args *ctx) &#123;</span><br><span class="hljs-string">    int opcode = ctx-&gt;args[1];</span><br><span class="hljs-string">    // 编译时会重写为: `bpf_tail_call(ctx, program_array_map, index)`</span><br><span class="hljs-string">    syscall.call(ctx, opcode);</span><br><span class="hljs-string">    // 除非上面的tail call失败, 否则下面的语句将不会执行</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Another syscall: %d&quot;, opcode);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_execve(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Executing a program&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_timer(struct bpf_raw_tracepoint *ctx) &#123;</span><br><span class="hljs-string">    if (ctx-&gt;args[1] == 222) &#123;</span><br><span class="hljs-string">        bpf_trace_printk(&quot;Creating a timer&quot;);</span><br><span class="hljs-string">    &#125; else if (ctx-&gt;args[1] == 226) &#123;</span><br><span class="hljs-string">        bpf_trace_printk(&quot;Deleting a timer&quot;);</span><br><span class="hljs-string">    &#125; else &#123;</span><br><span class="hljs-string">        bpf_trace_printk(&quot;Some other timer operation&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int ignore_opcode(void *ctx) &#123;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program)<br>b.attach_raw_tracepoint(tp=<span class="hljs-string">&quot;sys_enter&quot;</span>, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br>ignore_fn = b.load_func(<span class="hljs-string">&quot;ignore_opcode&quot;</span>, BPF.RAW_TRACEPOINT)<br>exec_fn = b.load_func(<span class="hljs-string">&quot;hello_exec&quot;</span>, BPF.RAW_TRACEPOINT)<br>timer_fn = b.load_func(<span class="hljs-string">&quot;hello_timer&quot;</span>, BPF.RAW_TRACEPOINT)<br><br>prog_array = b.get_table(<span class="hljs-string">&quot;syscall&quot;</span>)<br>prog_array[ct.c_int(<span class="hljs-number">59</span>)] = ct.c_int(exec_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">222</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">226</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">21</span>)] = ct.c_int(ignore_fn.fd)<br></code></pre></td></tr></table></figure><p>有几点注意事项:</p><ol><li><code>b.load_func(&quot;ignore_opcode&quot;, BPF.RAW_TRACEPOINT)</code>中，<code>load_func</code>的第一个参数需要是一个eBPF program；第二个参数可以是<code>BPF.RAW_TRACEPOINT</code>、<code>BPF.KPROBE</code>等其他值，具体是什么，要看tail call的&quot;父亲&quot;是什么，如果ebpf程序绑定的是一个tracepoint，那么就需要指定为<code>BPF.RAW_TRACEPOINT</code>，如果ebpf程序绑定的是一个kprobe，就需要指定为<code>BPF.KPROBE</code>.</li><li>上面<code>hello</code>和<code>ignore_opcode</code>的参数都定义为<code>void* ctx</code>，但由于其<code>父亲</code>的上下文来自tracepoint，因此具体的指针类型也是可知的，完全可以声明为: <code>struct bpf_raw_tracepoint *ctx</code>. 如果在kprobe/uprobe下，其参数类型就应该是<code>struct pt_regs *ctx</code>.</li></ol><blockquote><p><code>pt_regs</code> is at the high end of kernel stack, is mainly used for saving user registers in user-kernel mode switching.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-准备工作&quot;&gt;&lt;/a&gt; 1. 准备工作&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;这一章的主要内容是用eBPF写一个Hellow World程序，因此就需要开始一些简单的环境</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    <category term="eBPF" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/eBPF/"/>
    
    
  </entry>
  
  <entry>
    <title>(一)什么是eBPF?为什么eBPF非常重要?</title>
    <link href="https://www.torch-fan.site/2023/04/11/eBPF/"/>
    <id>https://www.torch-fan.site/2023/04/11/eBPF/</id>
    <published>2023-04-11T04:32:30.000Z</published>
    <updated>2023-04-11T11:08:11.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在将会开始一个较为长期的的笔记系列，来记录eBPF的学习过程。这系列的笔记并不会把eBPF的历史、eBPF的概念等内容抄上来复述一遍，如果遇到不懂的概念还需要自己主动去查找资料去思考和学习，带有思考的阅读价值可能会更大一些。这一系列的笔记主要是参考<code>《Learning eBPF》</code>这本官方给出的电子书，当这一系列结束时，这本书也就阅读完毕，希望写者与读者都能成为eBPF的beginner水平~</p></blockquote><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>  eBPF(<code>extended Berkeley Packet Filter</code>)是一个革命性的内核工具：通过使用这个工具，开发者们可以动态地向内核装载一些自定义代码来改变内核的行为，其意义将在下面展开描述。虽然介绍一件事物的背景显得很枯燥，但是了解一件事物发展路线，可以帮助我们理解每个feature后面的insight，学习最大的快乐就是能相互交织、融会贯通，不是吗？</p><p>  eBPF的众多功能中，经常被提及的有：</p><ul><li>Performance tracing(<code>perf</code>)</li><li>High-performance networking(<code>efficiency</code>)</li><li>Detecting and preventing malicious activity(<code>security</code>)</li></ul><p>  在后面我们会发现，eBPF的相关工具虽然数量众多，但是仍然无法脱离性能监控、高效和安全这三点。</p><p>如果回到eBPF上，会发现与之相关的系统调用叫<code>bpf()</code>,eBPF和BPF的关系也影射了eBPF的部分发展历史，可以去查询相关资料详细了解。</p><p>在2014年，<font color="cyan"><strong>内核3.18版本</strong></font>更新时，BPF演变成了我们现在所说的&quot;extended BPF&quot;或者&quot;eBPF&quot;。这次演变的主要包含这几点重要变化(为了避免翻译引起的歧义，这里给出了原文):</p><blockquote><ul><li>The BPF instruction set was completely overhauled to be more efficient on 64-bit machines, and the interpreter was entirely rewritten</li><li>eBPF <em>maps</em> ware introduced, which are data structures that can be accessed by BPF programs and by user space applications, allowing information to be shared between them.</li><li>The <code>bpf()</code> system call was added so that user space programs can interact with eBPF programs in the kernel.</li><li>Several BPF helper functions were added.</li><li>The eBPF verifier was added to ensure that eBPF programs are safe to run.</li></ul></blockquote><ul><li>BPF指令集经过了大幅优化来保证在64位操作系统中有更好的性能，并且BPF解释器被完全重写。</li><li>处在内核中的数据结构<code>eBPF maps</code>被设计出来，该数据结构可以被所有BPF程序和用户态程序访问，实现信息共享功能。</li><li>添加了一个系统调用<code>bpf()</code>，从而允许用户态程序能够与处在内核态的eBPF程序进行交互。</li><li>添加了若干个BPF辅助函数（如生成随机数的函数）</li><li>增加了eBPF验证器来保证eBPF程序的安全可靠（不会导致系统或者其他进程崩溃）</li></ul><p>  事实上，eBPF并非什么小众的黑科技，自<font color="cyan"><strong>2015年内核版本4.2</strong></font>之后，各大公司已经在实际生产环境中开始使用eBPF这一项技术，在2018年之后其应用落地的案例出现的则更加频繁。</p><h1 id="如何命名"><a class="markdownIt-Anchor" href="#如何命名"></a> 如何命名？</h1><p>  eBPF的应用范围已经远不止报文过滤(packet filtering)这一项功能，其简写——eBPF已经远无法涵盖其具有的强大作用，至今俨然成了一个专有名词。此外由于绝大多数的Linux 内核都已经支持了BPF的扩展部分，因此人们也逐渐将eBPF和BPF混作一谈。在Linux内核源码和eBPF程序中，都使用的术语是BPF，例如eBPF相关的系统调用名字是<code>bpf()</code>, 所有的辅助函数(helper function)都以<code>bpf_</code>开头，BPF程序使用前缀<code>BPF_PROG_TYPE</code>来标识。因此有人说BPF这个词时，极大概率说的是eBPF；当有人说eBPF时，那他就是在说eBPF。随着eBPF热度的不断增长，这种“狭隘的错误”可能还会不断放大。</p><h1 id="linux内核"><a class="markdownIt-Anchor" href="#linux内核"></a> Linux内核</h1><p>  Linux内核是硬件和应用程序之间的一层software layer。应用程序运行所在的非特权层称为用户空间(<em>user space</em>)，用户空间中的进程无法直接访问硬件。这些应用程序需要使用系统调用(<code>syscall</code>)请求内核来代为操作。硬件访问通常包括文件读写、网络报文的发送和接收、访问内存等等。内核还会负责调度工作，用于协调进程的运行。具体如下图所示（引自书中Fig 1-1)</p><p><img src="ebpf_1.png" alt="Linux内核" /></p><p>  一般而言，程序开发者很少会自己调用syscall，高级编程语言通常对系统调用进行了封装。但是如果想直到一个进程运行过程中，内核被调用了多少次（一般发生在调用syscall或者发生中断时），可以使用<code>strace</code>命令来展示应用程序调用的所有syscall。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">strace -c <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p><img src="ebpf_2.png" alt="strace执行结果" /></p><p>  正因为应用程序和内核交互密切，通过eBPF进行代码注入，我们就能更清晰的看到应用程序究竟访问了哪些文件、使用了哪些端口、访问了哪块内存。但是完成这个代码注入的拦截过程，eBPF程序就需要在内核中添加新的功能。</p><h1 id="为内核添加新的功能"><a class="markdownIt-Anchor" href="#为内核添加新的功能"></a> 为内核添加新的功能</h1><p>  Linux内核有三千多万行代码。对内核的任何修改都要求开发者自身对内核有非常高的熟练程度，除非你是内核的开发者，否则这是非常难的。</p><p>  此外，如果你想让你的代码修改贡献到内核中，遇到的不只有技术问题。如果想要让你的代码修改称为正式发行版本的一部分，这部分代码需要让整个社区的人(甚至是Linus Trovalds——creator and main developer of Linux)都接受并认可。据统计，提交的内核补丁中只有1/3被接受。</p><p>  即使你的代码修改被认可了，Linux内核的版本的发行需要若干个月时间去等待；即使新的版本中包含了你的修改，还要记得，不同的Linux发行版（Ubuntu、Debian等）并不会直接使用最新的Linux内核，因为需要在内核之上增加一些内容。当你所期待的Linux发行版终于用上带有你提交补丁的内核版本时，时间已经几年过去了。</p><h1 id="内核模块-kernel-modules"><a class="markdownIt-Anchor" href="#内核模块-kernel-modules"></a> 内核模块 (Kernel Modules)</h1><p>  如果不想花几年时间去等待内核的改变，还有一种可选方案：使用内核模块。Linux内核支持动态加载和卸除内核模块。如果想要扩展内核功能，可以写一个内核模块来完成。</p><p>  但是编写内核仍然是需要内核相关编程经验，此外内核模块的安全性也是非常大的隐患。再一步的说，即使模块能安全的运行也不代表其不会崩溃，进而导致系统或者其他应用程序的异常退出。这一系列的隐患，使得内核模块的使用受到极大的限制。</p><h1 id="ebpf程序的动态加载"><a class="markdownIt-Anchor" href="#ebpf程序的动态加载"></a> eBPF程序的动态加载</h1><p>  迄今为止，内核模块功能添加的困难主要是开发难度、更新周期、安全性保证和功能的可靠性。eBPF程序可以可以动态地从内核中加载和卸载。一旦eBPF程序绑定了一个事件，当该事件触发时(无论因何触发)该eBPF程序都会执行。</p><blockquote><p>譬如当一个eBPF程序绑定了打开文件相关的系统调用时，每当一个进程打开文件时都会触发eBPF程序的执行。</p></blockquote><h1 id="ebpf程序的高性能"><a class="markdownIt-Anchor" href="#ebpf程序的高性能"></a> eBPF程序的高性能</h1><p>  一旦eBPF程序被加载进内核，JIT-compiler就会将其编译为原生的CPU机器指令，保证最高的运行性能。最重要的是，程序的执行没有在<font color="pink"><strong>内核态和用户态之间的内存复制开销</strong></font>。因此native的机器指令和无内核态用户态之间的内存复制，使得eBPF程序的执行效率非常的高。</p><h1 id="云原生环境cloud-native-environments中的ebpf"><a class="markdownIt-Anchor" href="#云原生环境cloud-native-environments中的ebpf"></a> 云原生环境(Cloud Native Environments)中的eBPF</h1><p>  在Kubernetes环境中，同一机器上所有Pods中的所有containers都使用一个同一个内核(即共享宿主机的内核)。当使用eBPF对内核进行插桩后，在该节点上的所有容器化实例都能访问并调用该eBPF程序。在云原生环境中，使用eBPF就具有非常大的优势：</p><ol><li>不需要对应用程序的源码或者配置进行修改</li><li>只有eBPF程序加载进内核并绑定相应事件，eBPF程序就能观测已经在运行的应用程序进程。</li></ol><p>  在云原生环境中进行插桩注入的工具还有比较知名的<em>sidecar model</em>,它可以为Kubernetes应用提供logging、tracing、security和service mesh功能。使用<em>sidecar model</em>比在源码中进行代码注入要好一些，但是也有一些缺点：</p><ol><li>应用程序所在Pod必须重启从而添加<code>sidecar</code></li><li>必须要在应用程序的配置yaml文件中添加一些东西（譬如加label来标识要注入的目标，如果没有正确的标识注入目标，sidecar将不会进行相应相应的注入）</li><li>sidecar注入会导致Pod启动时间大幅延长、竞态问题。</li><li>如果一些网络相关的功能是基于sidecar实现的话，其网络时延会变得相对较大。因为所有流量都需要反复进出内核态的网络协议栈。</li></ol><p><img src="ebpf_3.png" alt="sidecar实现的网络结构延迟较高" /></p><p>  通过使用eBPF就能避免sidecar的这些问题。不需要对应用程序进行任何标注来确定目标，并且对安全性也能有足够的保证（见<code>Learning-eBPF P13</code>)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;现在将会开始一个较为长期的的笔记系列，来记录eBPF的学习过程。这系列的笔记并不会把eBPF的历史、eBPF的概念等内容抄上来复述一遍，如果遇到不懂的概念还需要自己主动去查找资料去思考和学习，带有思考的阅读价值可能会更大一些。这一系列的笔记主要是参</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    <category term="eBPF" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/eBPF/"/>
    
    
  </entry>
  
  <entry>
    <title>Skip List(跳表)</title>
    <link href="https://www.torch-fan.site/2023/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Skip-List-%E8%B7%B3%E8%A1%A8/"/>
    <id>https://www.torch-fan.site/2023/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Skip-List-%E8%B7%B3%E8%A1%A8/</id>
    <published>2023-04-08T06:16:36.000Z</published>
    <updated>2023-04-08T08:37:53.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跳表"><a class="markdownIt-Anchor" href="#跳表"></a> 跳表</h1><p>跳表在很多数据结构的书中都不会提到，但是由于Redis的zset底层有时是基于跳表实现的，因此跳表这个数据结构在面试时成为一个有概率被问起的热点问题。</p><blockquote><p>In computer science, a <code>skip list</code> (or <code>skiplist</code>) is a <code>probabilistic data structure</code> that allows <font color="cyan"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> average complexity for search</strong></font> as well as <font color="red"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> average complexity for insertion within an ordered sequence of n elements</strong></font>.</p></blockquote><p>从维基百科中的定义我们可以了解到，跳表最重要的特性是对于一个有序列表，可以在对数复杂度内搜索一个数，并且可以在对数时间复杂度内插入一个数。下面列举了跳表复杂度相关的内容，</p><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">平均</th><th style="text-align:center">最差情况下</th></tr></thead><tbody><tr><td style="text-align:center">空间复杂度</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center">搜索一个元素</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center">插入一个元素</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center">删除一个元素</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td></tr></tbody></table><h1 id="跳表的结构"><a class="markdownIt-Anchor" href="#跳表的结构"></a> 跳表的结构</h1><p>跳表是一个多层的结构，第一层就是普通的有序链表，包含了序列中所有元素，如下图所示。仅有一层结构的跳表与普通的数据结构链表并无而致，为了提高跳表的性能，第一层之上添加了若干层，这些层有个fashion的名字——express lane(快车道)。</p><p><img src="skiplist_1.png" alt="图1.跳表的结构" /></p><p>对于如何从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>层逐层向上构建，维基百科给了这样一种说法：</p><p>给定一个固定的概率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>(通常是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">1/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">4</span></span></span></span>)，第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>层中的节点以概率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的可能性出现在第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>层。在平均情况下，每个节点会出现在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1/(1-p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span>个链表中，且<font color="skyblue"><strong>顶层的元素会出现在每一层链表中</strong></font>。整个跳表<font color="red"><strong>平均包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi></mrow></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_{1/p}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>个链表</strong></font>。逐层构建好的跳表如下图所示:</p><p><img src="skiplist_2.png" alt="图2.构建好的跳表结构" /></p><h1 id="跳表的操作"><a class="markdownIt-Anchor" href="#跳表的操作"></a> 跳表的操作</h1><h2 id="1-查询"><a class="markdownIt-Anchor" href="#1-查询"></a> 1. 查询：</h2><ol><li>从顶层开始，每次找到<font color="red"><strong>最后一个</strong></font>小于<code>key</code>的节点<code>n</code>（如果等于，直接返回已找到；如果没找到这样的节点，则直接返回不存在），然后向下一层到第<code>i</code>层</li><li>从当前层继续重复步骤1，如果未返回找到或不存在，则从<code>n'</code>所在层<code>i</code>再往下一层到<code>i-1</code>层；</li><li>重复步骤2操作</li></ol><h2 id="2-插入"><a class="markdownIt-Anchor" href="#2-插入"></a> 2. 插入:</h2><p>插入也可以沿用查询操作时的逻辑判断，每次都从当前层找到<font color="skyblue"><strong>最后一个小于</strong></font><code>key</code>的节点<code>n</code>，插入的位置就是第1层节点<code>n</code>所在位置。</p><h2 id="3-删除"><a class="markdownIt-Anchor" href="#3-删除"></a> 3. 删除:</h2><p>同样的，我们每次都找到最后一个小于<code>key</code>的节点，直到第1层。将第1层中最后一个小于<code>key</code>的节点的后续第一个节点删除即可完成该操作。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料:</h1><p>[1]: <a href="https://en.wikipedia.org/wiki/Skip_list">https://en.wikipedia.org/wiki/Skip_list</a></p><p>[2]: <a href="https://oi-wiki.org/ds/skiplist/">https://oi-wiki.org/ds/skiplist/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跳表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#跳表&quot;&gt;&lt;/a&gt; 跳表&lt;/h1&gt;
&lt;p&gt;跳表在很多数据结构的书中都不会提到，但是由于Redis的zset底层有时是基于跳表实现的，因此跳表这个数据结构在面试时成为一个有概率被问起的热点</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="https://www.torch-fan.site/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据结构" scheme="https://www.torch-fan.site/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>面试高频题:海量数据中找到具有某个特征的数字</title>
    <link href="https://www.torch-fan.site/2023/04/03/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%88%B0%E5%85%B7%E6%9C%89%E6%9F%90%E4%B8%AA%E7%89%B9%E5%BE%81%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://www.torch-fan.site/2023/04/03/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%88%B0%E5%85%B7%E6%9C%89%E6%9F%90%E4%B8%AA%E7%89%B9%E5%BE%81%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2023-04-03T05:49:26.000Z</published>
    <updated>2023-04-03T06:31:04.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目描述：有一个1G大小的文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词</p></blockquote><h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路：</h1><blockquote><p>这类面试题有个非常统一的特点，要处理的文件非常大而内存非常小，基本都需要用到归并思想，但是如何归并要视场景的不同而变化</p></blockquote><ol><li><p>在分而治之的背景下，统计词频首先需要解决“同步”和“通信”问题，或者是使用某种预处理能够避免不同子问题之间有交叉。一种想法是<font color="cyan"><strong>将不同数据映射到不同子文件中</strong></font>，在保证子文件足够小的情况下，确保相同的数字能够在一个子文件中，就能在子问题中解决词频的统计。最后排序在归并过程中解决。1G的文件、1M的内存，使用5000个子文件即可(5000 * 200K约等于1G，平均每个子文件只需占用200K内存)。</p></li><li><p>在划分子文件时有个技巧，一次读取整个文件是不可能的，需要<font color="red">设定一个文件指针，一次读取一个词</font>，计算Hash值后立即写入相应子文件中，然后移动指针，重复相应操作。这个过程并不需要太多的内存消耗（使用的空间几乎为常数）</p></li><li><p>题目要求返回频数最高的100词，那我们就可以在子文件中先统计词频最高的100个词，减少搜索的范围（这个过程可以用堆来完成）。保存成新的5000个子文件</p></li><li><p>最后我们对5000个子文件进行归并处理：<font color="red">每比较出一个较大词频的词，写入到文件中</font>(读的时候是一个文件一次读一个词，每得到一个结果就立即写入，这样占用的内存就很小了)，统计到100后终止。这一每次次归并就能将文件数减半，每个子文件包含最大的100个词频。</p></li></ol><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料:</h1><p>[1]: <a href="https://blog.csdn.net/Fly_as_tadpole/article/details/88375993">https://blog.csdn.net/Fly_as_tadpole/article/details/88375993</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;题目描述：有一个1G大小的文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，要求返回频数最高的100个词&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    
    <category term="面经" scheme="https://www.torch-fan.site/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得算法和倒水问题</title>
    <link href="https://www.torch-fan.site/2023/04/01/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://www.torch-fan.site/2023/04/01/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-01T02:05:24.000Z</published>
    <updated>2023-04-01T04:52:54.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>扩展偶极里德算法(Extended Euclidean algorithm, EXGCD), 用于求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax+by=gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>的一组可行解。</p><p>在面试中，面试官可能出一些看似是智力题的问题：有一个3升的杯子A和5升的杯子B，给你无限的水，如何倒出4升的水。</p><p>可能思路比较直观：</p><ol><li>先装满A，全部倒入B中</li><li>再装满A，将B装满，此时A中还剩下1L，B中有5L水</li><li>将B中的水全部倒掉，此时只有A中有1L水，倒入B中</li><li>将A再次装满，全部导入B中，此时B中有4L水</li></ol><p>但是，很容易发现，这个过程似乎并不是唯一的，我们还可以这样：</p><ol><li>先装满B，将B中水倒入A中装满A。此时A中有水3L，B有水2L。</li><li>将A中的水全部倒出，然后把B中的水全部倒入A，此时A有2L水，B为空。</li><li>再将B装满水，从B向A倒水直至满，此时A中有3L，B有4L水。</li><li>把A中水全倒了，我们就有4L水了。</li></ol><p>可以看到，这个倒水装水的过程并不是唯一的，用数学形式化这两个过程可以发现：</p><blockquote><p>+A表示将A装满， +B表示将杯B装满; -A表示将A中3L水倒出，-B表示将B中5L水倒出</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>+</mo><mi>A</mi><mo>−</mo><mi>B</mi><mo>+</mo><mi>A</mi><mo>=</mo><mn>4</mn><mi>L</mi><mspace linebreak="newline"></mspace><mi>B</mi><mo>−</mo><mi>A</mi><mo>+</mo><mi>B</mi><mo>−</mo><mi>A</mi><mo>=</mo><mn>4</mn><mi>L</mi></mrow><annotation encoding="application/x-tex">A + A - B + A = 4L \\B - A + B - A = 4L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">L</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">L</span></span></span></span></span></p><p>使用公式表示倒水、装水的这个过程，我们还能发现一个特点：我们一直都在杯满时倒水、杯空时装水。当杯只装一半水时，我们只进行转移操作——将一个杯中的水转移到另一个杯子里。</p><p>那么我们就可以从两个视角（假设只有两种杯子）来看到倒水问题了：</p><ol><li>不停的往A加水，转移到B中；A只要不为空就向B转移水，B只要满了就全部倒掉，最后有k(目标数)升水</li><li>不停的往B加水，转移到A中；B只要不为空就向A转移水，A只要满了就需要立即倒掉，最后留有k(目标数)升水</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>A</mi><mi mathvariant="normal">%</mi><mi>B</mi><mo>=</mo><mi>k</mi><mo separator="true">,</mo><mtext> m</mtext><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>n</mi><mi>B</mi><mi mathvariant="normal">%</mi><mi>A</mi><mo>=</mo><mi>k</mi><mo separator="true">,</mo><mtext> n</mtext><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">mA \% B= k,\text{ m}\in [1, +\infin]  \\n B \% A = k, \text{ n}\in [1, +\infin]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">A</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> m</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">%</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> n</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">]</span></span></span></span></span></p><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">A=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">B=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mi>m</mi><mi mathvariant="normal">%</mi><mn>5</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3m\%5=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord mathdefault">m</span><span class="mord">%</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，如果能找到这样一个m使得等式成立，则倒出目标数量水的意图就能达到。</p><h1 id="1-扩展欧几里得算法"><a class="markdownIt-Anchor" href="#1-扩展欧几里得算法"></a> 1. 扩展欧几里得算法</h1><p>将上面的倒水问题再形式化一下：<font color="green"><strong>用容积分别为a和b的水杯量出体积为c的水</strong></font>，相当于求解方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>x</mi><mtext> mod </mtext><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a\cdot x\text{ mod }b = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。</p><ul><li>如果a, b互质，可以保证问题有解。</li><li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo><mi mathvariant="normal">≔</mi></mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi>c</mi><mo><mi mathvariant="normal">≔</mi></mo><mi>k</mi><mo>⋅</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c\coloneqq gcd(a, b)或者c\coloneqq k\cdot gcd(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mop" style="position:relative;top:-0.03472em;">:</span></span><span class="mrel"><span class="mspace" style="margin-right:-0.06666666666666667em;"></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mop" style="position:relative;top:-0.03472em;">:</span></span><span class="mrel"><span class="mspace" style="margin-right:-0.06666666666666667em;"></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>时，可以用扩展欧几里得算法求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></li></ul><blockquote><p>注意到，如果a和b互质，则gcd(a,b)=1，那么第二点也必然成立。因此只要c不等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>⋅</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k\cdot gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，那么就无法找到一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，能够满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>x</mi><mtext> mod </mtext><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a\cdot x\text{ mod }b = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord text"><span class="mord"> mod </span></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p></blockquote><p>用扩展欧几里得算法公式来表示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi mathvariant="normal">或</mi><mo>:</mo><mo stretchy="false">(</mo><mi>k</mi><mi>a</mi><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>k</mi><mi>b</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax+by=gcd(a,b) \\或:(ka)x+(kb)y = k\cdot gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">或</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 扩展欧几里得算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">Exgcd</span>(b, a % b, x, y);<br>    <span class="hljs-type">int</span> t = x;<br>    x = y;<br>    y = t - (a/b) * y;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> a, b;<br>    a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">4</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;GCD: &quot;</span> &lt;&lt; <span class="hljs-built_in">Exgcd</span>(a * k, b * k, x, y) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便描述结果，我们用前言中的倒水例子来描述，还是3L、5L出4L。</p><p>即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mi>a</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">k=4,a=3,b=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>,程序的输出结果是:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GCD</span>: <span class="hljs-number">4</span><br><span class="hljs-attribute">x</span>: <span class="hljs-number">2</span>    y: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mi>a</mi><mo>=</mo><mn>5</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k=4,a=5,b=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>, 程序的输出结果是:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GCD</span>: <span class="hljs-number">4</span><br><span class="hljs-attribute">x</span>: -<span class="hljs-number">1</span>   y: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">k=1,a=3,b=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>, 程序的输出结果是:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GCD</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">x</span>: -<span class="hljs-number">1</span>   y: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>a</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">k=2,a=3,b=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>, 程序的输出结果是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GCD</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">x</span>: -<span class="hljs-number">1</span>   y: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>由此可见，k的数值对扩展欧几里得算法的结果并没有影响（仅对最后的gcd值造成倍数上的改变）。关于更多扩展欧几里得算法内容可以参考OI-WIKI的内容。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1]: <a href="https://oi-wiki.org/math/number-theory/gcd/">https://oi-wiki.org/math/number-theory/gcd/</a></p><p>[2]: <a href="https://blog.csdn.net/lanchunhui/article/details/50594649">https://blog.csdn.net/lanchunhui/article/details/50594649</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;扩展偶极里德算法(Extended Euclidean algorithm, EXGCD), 用于求&lt;span class=&quot;katex&quot;&gt;&lt;s</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="https://www.torch-fan.site/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数论" scheme="https://www.torch-fan.site/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库分库和分表基础概念</title>
    <link href="https://www.torch-fan.site/2023/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://www.torch-fan.site/2023/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2023-03-30T07:02:05.000Z</published>
    <updated>2023-03-30T13:11:04.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念：</h1><h2 id="名词列举"><a class="markdownIt-Anchor" href="#名词列举"></a> 名词列举:</h2><table><thead><tr><th style="text-align:center">名词</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Database</td><td style="text-align:center">库</td></tr><tr><td style="text-align:center">Table</td><td style="text-align:center">表</td></tr><tr><td style="text-align:center">Sharding</td><td style="text-align:center">分库/分表</td></tr></tbody></table><p>后端将数据量较大的数据表拆分到各个数据库中，拆分出的库叫做<font color="red"><strong>分库</strong></font>，分库中的表叫做<font color="red"><strong>分表</strong></font>。</p><h1 id="1-架构的演变"><a class="markdownIt-Anchor" href="#1-架构的演变"></a> 1. 架构的演变:</h1><ol><li>最开始只用单机数据库就足够了</li><li>后来面对越来多的请求，开始将读操作、写操作分离，<font color="skyblue"><strong>主库</strong>(Master)</font>负责写，<font color="red"><strong>从库副本</strong></font>(Slaver Replication)负责读。从库从主库中不断同步更新数据，保持数据一致。当读请求增多时，从库可以不断地水平扩展来解决该问题。</li><li>然而当用户数量达到一定量级后，写请求越来越多。仅仅靠增加主库不能简单的解决问题，因为会带来数据一致性问题，数据同步会使得问题更加复杂。由此就引出了<font color="skyblue"><strong>分库分表</strong></font>（sharding），对写操作进行切分。</li></ol><p><img src="database_sharding.png" alt="Database Sharding" /></p><h1 id="2-垂直纵向切分vertical-sharding"><a class="markdownIt-Anchor" href="#2-垂直纵向切分vertical-sharding"></a> 2. 垂直（纵向）切分(Vertical Sharding)</h1><h2 id="21-垂直分库"><a class="markdownIt-Anchor" href="#21-垂直分库"></a> 2.1 垂直分库</h2><blockquote><p>垂直分库是根据业务的耦合性，将<font color="cyan"><strong>关联度低的不同表</strong></font>存储在不同的数据库。</p></blockquote><p>通过按照业务将不同表分类，放在不同数据库上，而每个库又可以放在不同服务器上。其核心理念是专库专用，带来的提升是：</p><ul><li>解决业务层面的耦合，业务清晰</li><li>能对不同业务的数据进行分级管理、维护、监控、扩展等</li><li>高并发场景下，垂直分库可以一定程度上提升IO、数据库连接数、降低单机硬件资源的瓶颈。</li></ul><h2 id="22-垂直分表"><a class="markdownIt-Anchor" href="#22-垂直分表"></a> 2.2 垂直分表</h2><blockquote><p>垂直分表则面向表中的列，将<font color="red"><strong>不经常用、长度较大</strong></font>的字段拆分到扩展表中。通过大表拆小表的方式，方便开发和维护，还能避免跨页问题。</p><blockquote><p>MySQl底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。</p></blockquote><p>数据库中<font color="cyan"><strong>以行为单位</strong></font>加载进缓存，如果每一行数据量越小，能同时加载的行数就提升，缓存命中的概率就更高，就能减少硬盘IO。将高频访问的字段放进主表也是相似的道理。</p></blockquote><p>垂直分表后，如果需要同时查询主、从表中的数据，不应使用join联表查询，而应进行两次（视从表数量而定）数据查询。因为join的性能开销较大，并且联表查询时会将两行合并，导致跨页。</p><h1 id="3-水平横向切分horizontal-sharding"><a class="markdownIt-Anchor" href="#3-水平横向切分horizontal-sharding"></a> 3. 水平（横向）切分（Horizontal Sharding）</h1><blockquote><p>根据业务或者字段访问频率去垂直切分的粒度有限，或者即使垂直切分了数据行数巨大也存在单库读写、存储性能瓶颈。这时需要进行水平切片。</p></blockquote><h2 id="31-库内分表仅分表"><a class="markdownIt-Anchor" href="#31-库内分表仅分表"></a> 3.1 库内分表（仅分表）</h2><p>库内分表只能解决单一表数据量过大的问题，但没有将表分布到不同的库上。对MySQL来说帮助不大，所有的数据库连接请求还是竞争同一个物理机的CPU、内存和网络IO。</p><h2 id="32-分库分表既分库也分表"><a class="markdownIt-Anchor" href="#32-分库分表既分库也分表"></a> 3.2 分库分表（既分库也分表）</h2><p>将一个表的数据划分到不同节点上才能尽可能避免单个节点的瓶颈约束。</p><h2 id="33-水平切分的方式"><a class="markdownIt-Anchor" href="#33-水平切分的方式"></a> 3.3 水平切分的方式：</h2><h3 id="331-根据数值范围range"><a class="markdownIt-Anchor" href="#331-根据数值范围range"></a> 3.3.1 根据数值范围(Range)</h3><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点：</h4><ol><li>扩展性和可维护性好，每次只需要<font color="cyan"><strong>将新的数据存入到新的库中</strong></font>，无需对其它分片进行数据迁移。</li><li>单表大小可控（只要确定划分的数值范围即可）</li><li>使用分片的条件字段进行范围查询时，连续分片可快速定位到分片进行查询，有效避免跨分片查询的问题。</li></ol><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点：</h4><p><font color="red"><strong>热点数据不均匀</strong></font>：有的分片中对应数据被频繁访问，而有的分片数据极少被访问。例如新注册用户可能比较活跃，而10年“老兵”可能许久都未曾上线了。数据访问密度的不均衡，减弱了分库分表的作用，单个节点仍然可能成为限制整个系统的瓶颈。</p><h3 id="332-使用取模mod"><a class="markdownIt-Anchor" href="#332-使用取模mod"></a> 3.3.2 使用取模(Mod)</h3><h4 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点：</h4><p>数据分片相对均匀，不易出现热点数据库问题。</p><h4 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点：</h4><ol><li>对分片进行扩容的时候需要进行数据迁移（可以使用一致性Hash算法解决）</li><li>分片查询时可能增加查询难度。譬如查询数据中是否存在某一项时，需要同时查询所有分片，然后聚合，最后返回给应用，Sharding此时反而成为了累赘。</li></ol><h3 id="333-使用一致性hash算法consistent-hashing"><a class="markdownIt-Anchor" href="#333-使用一致性hash算法consistent-hashing"></a> 3.3.3 使用一致性Hash算法(Consistent Hashing)</h3><blockquote><p>事实上，这个所谓的一致性算法和Chord环有些相似</p></blockquote><blockquote><p>一致性hash算法：对于分布式存储，不同机器上存储了不同对象的数据，需要使用Hash函数建立从数据到服务器之间的映射关系。在物理节点数量不变的情况下，普通Hash算法就已经能胜任这个映射过程。但是一旦<font color="red"><strong>需要对节点进行扩容</strong></font>，那么会造成大量的数据迁移，导致网络通信压力突增，严重时还会导致数据库宕机。</p></blockquote><p>一致性Hash算法正是为了保证当机器增加或者减少时，<font color="pink"><strong>节点之间的数据迁移只限于两节点之间</strong></font>，不会造成全局的网络问题。</p><h4 id="环形hash空间"><a class="markdownIt-Anchor" href="#环形hash空间"></a> 环形Hash空间</h4><p>按照常用的Hash算法将所有key哈希到一个具有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个桶的空间中，将这些数字头尾相连，形成逻辑上的闭环，如下图所示：</p><p><img src="ch_1.png" alt="环形空间" /></p><p>接着我们将数据object1，object2…对象映通过特定的Hash计算，将其映射到Hash环上，如下图所示:</p><p><img src="ch_2.png" alt="对象映射到环形空间中" /></p><p>假设我们有Node1、Node2…若干台机器，通过Hash算法（机器IP或者其他机器的唯一标识）得到对应环上的KEY，映射到环中，示意图如下：</p><p><img src="ch_3.png" alt="将节点映射到环形空间中" /></p><p>如图所示，将节点也映射到环形空间中之后，我们就可以将不大于节点的数据存到对应节点中。当一个节点被删除时，由其第一后继节点接替其数据的存储；当一个节点被添加时，小于该节点且大于节点前驱节点key值的所有数据都转移到新的节点上。</p><h4 id="优点-3"><a class="markdownIt-Anchor" href="#优点-3"></a> 优点：</h4><p>扩容后最多在两个节点之间迁移数据，极大的减少了扩容时数据库迁移的负担。</p><h4 id="存在的问题"><a class="markdownIt-Anchor" href="#存在的问题"></a> 存在的问题：</h4><p>当集群的节点数量较少时，就可能会出现节点在环形Hash空间分布不均衡的问题。会造成<font color="cyan"><strong>Hash环的倾斜</strong></font>。大部分的数据只存放在少量节点上，大量节点上数据稀少。各个节点之间负载不均衡。</p><p>解决的办法在于创建虚拟节点：每个物理节点对应多个虚拟节点，这样一来一定程度上可以减少Hash环倾斜的问题。</p><h3 id="334-使用snowflake进行分片"><a class="markdownIt-Anchor" href="#334-使用snowflake进行分片"></a> 3.3.4 使用Snowflake进行分片</h3><blockquote><p>待详细补充</p></blockquote><blockquote><p>主要思想是使用该算法生成带有<font color="cyan"><strong>时间戳信息和分片维度（数据库分片值和表分片值）</strong></font></p></blockquote><h1 id="4-数据库分片引入的问题"><a class="markdownIt-Anchor" href="#4-数据库分片引入的问题"></a> 4. 数据库分片引入的问题</h1><blockquote><p>内容较多，待补充</p></blockquote><h2 id="41-分布式事务"><a class="markdownIt-Anchor" href="#41-分布式事务"></a> 4.1 分布式事务</h2><h2 id="42-跨节点join联表查询"><a class="markdownIt-Anchor" href="#42-跨节点join联表查询"></a> 4.2 跨节点join联表查询</h2><h2 id="43-跨节点聚合"><a class="markdownIt-Anchor" href="#43-跨节点聚合"></a> 4.3 跨节点聚合</h2><h2 id="44-节点扩容"><a class="markdownIt-Anchor" href="#44-节点扩容"></a> 4.4 节点扩容</h2><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料：</h1><p>1: <a href="https://help.aliyun.com/document_detail/133453.html">分库分表</a></p><p>2: <a href="https://juejin.cn/post/6844903648670007310">MySQL 分库分表方案，总结的非常好！</a></p><p>3: <a href="https://cloud.tencent.com/developer/article/1819045">实战彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表）</a></p><p>4: <a href="https://blog.csdn.net/weixin_44062339/article/details/100491744">彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表）</a></p><p>5: <a href="https://blog.csdn.net/qq_32828253/article/details/109586242">数据库分库分表及其切片方案（垂直切分、水平切分）</a></p><p>6: <a href="https://zhuanlan.zhihu.com/p/129049724">一致性哈希算法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#基本概念&quot;&gt;&lt;/a&gt; 基本概念：&lt;/h1&gt;
&lt;h2 id=&quot;名词列举&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#名词列举&quot;&gt;&lt;/a&gt; 名词列举:&lt;/</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据库" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="基础知识" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>通过Remote Forward让无联网权限服务器联网</title>
    <link href="https://www.torch-fan.site/2023/02/09/%E9%80%9A%E8%BF%87Remote-Forward%E8%AE%A9%E6%97%A0%E8%81%94%E7%BD%91%E6%9D%83%E9%99%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%81%94%E7%BD%91/"/>
    <id>https://www.torch-fan.site/2023/02/09/%E9%80%9A%E8%BF%87Remote-Forward%E8%AE%A9%E6%97%A0%E8%81%94%E7%BD%91%E6%9D%83%E9%99%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%81%94%E7%BD%91/</id>
    <published>2023-02-09T11:44:19.000Z</published>
    <updated>2023-02-19T07:43:18.956Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先回顾一下remote forward的作用：将本地服务转发出去，以SSH服务器为媒介，外部访问SSH服务器的特定端口，流量会转发到本地端口上</p></blockquote><p>参考资料：<a href="https://unix.stackexchange.com/questions/116191/give-server-access-to-internet-via-client-connecting-by-ssh">https://unix.stackexchange.com/questions/116191/give-server-access-to-internet-via-client-connecting-by-ssh</a></p><h1 id="1-安装squid-以ubuntu为例"><a class="markdownIt-Anchor" href="#1-安装squid-以ubuntu为例"></a> 1. 安装Squid （以Ubuntu为例）</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># squid的默认监听端口是`3128`</span><br>sudo apt install squid<br><br><span class="hljs-comment"># Make sure  the service is started</span><br>sudo service squid start<br><br><span class="hljs-comment"># 编辑配置文件 </span><br>sudo vim /etc/squid/squid.conf<br></code></pre></td></tr></table></figure><p>在配置文件中注释掉: <code>http_access deny all</code>, 并且添加: <code>http_access allow all</code></p><h1 id="2-如果host使用了代理譬如需要访问google服务等内容"><a class="markdownIt-Anchor" href="#2-如果host使用了代理譬如需要访问google服务等内容"></a> 2. 如果Host使用了代理（譬如需要访问Google服务等内容）：</h1><blockquote><p>有一点需要注意，在squid中加入代理设置会和clash的代理冲突，导致clash软件出现一些奇怪BUG, 或者导致squid的转发出现中断； 这时需要重新启动clash，然后重新建立转发隧道</p></blockquote><p>假设Host使用的代理为：<code>127.0.0.1:7890</code><br />那么需要在配置文件<code>/etc/squid/squid.conf</code>中添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">refresh_pattern (Release|Packages(.gz)*)$ 0 20% 2880<br>cache_peer 127.0.0.1 parent 7890 0 no-query default<br>ever_direct deny local-servers  <span class="hljs-comment"># 本地的域名直连</span><br>never_direct allow all<br></code></pre></td></tr></table></figure><blockquote><p>后面还需要<code>sudo service squid restart</code>重启一下服务，同时记得暂时断开所有使用了squid服务的SSH连接。</p></blockquote><h1 id="3-在server上配置"><a class="markdownIt-Anchor" href="#3-在server上配置"></a> 3. 在Server上配置：</h1><blockquote><p>下面这个可以写进配置文件里，在登陆用户时使得该配置自动生效；也可以就在终端临时配置；</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;http://127.0.0.1:3129&quot;</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;http://127.0.0.1:3129&quot;</span><br></code></pre></td></tr></table></figure><h1 id="4-remote-forward"><a class="markdownIt-Anchor" href="#4-remote-forward"></a> 4. Remote forward</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -R 3129:localhost:3128 user@server_ip<br></code></pre></td></tr></table></figure><p>也可以使用autossh来建立一个持久化的SSH隧道，具体可见：<a href="https://wiki.gentoo.org/wiki/Autossh">https://wiki.gentoo.org/wiki/Autossh</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 需要配好密钥，使得其可以免密登陆</span><br>autossh -M 20000 -f -NT -R 3129:localhost:3128 user@server_id<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;首先回顾一下remote forward的作用：将本地服务转发出去，以SSH服务器为媒介，外部访问SSH服务器的特定端口，流量会转发到本地端口上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://unix.sta</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建VECROsim笔记</title>
    <link href="https://www.torch-fan.site/2023/01/03/%E6%90%AD%E5%BB%BAVECROsim%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.torch-fan.site/2023/01/03/%E6%90%AD%E5%BB%BAVECROsim%E7%AC%94%E8%AE%B0/</id>
    <published>2023-01-03T11:49:01.000Z</published>
    <updated>2023-02-08T04:59:31.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-相关资料"><a class="markdownIt-Anchor" href="#1-相关资料"></a> 1. 相关资料：</h1><ul><li>代码仓库：<a href="https://github.com/etigerstudio/VECROsim">https://github.com/etigerstudio/VECROsim</a></li><li>相关论文: <a href="https://ieeexplore.ieee.org/abstract/document/9978950">VECROsim: A Versatile Metric-oriented Microservice Fault Simulation System</a></li></ul><blockquote><p>搭建过程中有一些问题是镜像问题，除了第一次启动minikube需要设置proxy外，拉取完所有镜像后，请stop minikube，然后重新启动：<code>minikube start --image-mirror-country=cn --registry-mirror https://dockerhub.azk8s.cn</code></p></blockquote><h1 id="2-部署过程"><a class="markdownIt-Anchor" href="#2-部署过程"></a> 2. 部署过程:</h1><blockquote><p>部署过程中如果遇到问题，但是一直摸不着头脑，不如<code>minikube dashboard</code>看一下(比如查看镜像名是否正确), 错误信息更加准确有效～</p><p>如果想进入minikube虚拟机： <code>minikube ssh</code></p><p>如果想进入pod: <code>kubectl exec -it &lt;pod&gt; -n &lt;namespace&gt; -- /bin/sh</code></p><p>如果觉得minikube给的资源太少：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube stop<br>minikube config <span class="hljs-built_in">set</span> cpus 4<br>minikube start<br></code></pre></td></tr></table></figure></blockquote><h2 id="21-安装minikube和go"><a class="markdownIt-Anchor" href="#21-安装minikube和go"></a> 2.1 安装minikube和Go：</h2><p><a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64<br>sudo install minikube-linux-amd64 /usr/local/bin/minikube<br>minikube version<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://golang.google.cn/dl/go1.19.4.linux-amd64.tar.gz<br>sudo <span class="hljs-built_in">rm</span> -rf /usr/local/go &amp;&amp; sudo tar -C /usr/local -xzf go1.19.4.linux-amd64.tar.gz<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=$PATH:/usr/local/go/bin&#x27;</span> &gt;&gt; ~/.profile<br>go version<br></code></pre></td></tr></table></figure><h2 id="22-创建集群"><a class="markdownIt-Anchor" href="#22-创建集群"></a> 2.2 创建集群：</h2><blockquote><p>注意，创建集群时，如若需要VPN. 代理的配置请见笔记：<a href="https://www.torch-fan.site/2022/07/20/Ubuntu%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/">Ubuntu下配置代理</a></p><p>minikube会创建一个网卡用于和主机通信，如果使用VPN务必将minikube的网卡IP忽略掉，这个IP地址在部署过程中会给出提示，所以不必担心不知道</p><p><code>minikube start --cpus=8 --memory 8196 --disk-size 32g --docker-env http_proxy=http://192.168.8.2:7890 --docker-env https_proxy=http://192.168.8.2:7890 --docker-env no_proxy=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24,192.168.49.2 --image-mirror-country=cn</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start --cpus=8 --memory=8196 --disk-size 32g --image-mirror-country=cn<br>minikube ssh docker pull mongo<br></code></pre></td></tr></table></figure><h2 id="23-构建镜像"><a class="markdownIt-Anchor" href="#23-构建镜像"></a> 2.3 构建镜像:</h2><ul><li>vecro-base: <a href="https://github.com/etigerstudio/vecro-base">https://github.com/etigerstudio/vecro-base</a></li><li>vecro-mongodb: <a href="https://github.com/etigerstudio/vecro-mongodb">https://github.com/etigerstudio/vecro-mongodb</a></li></ul><blockquote><p>推荐使用我修改后的仓库：</p></blockquote><ul><li>vecro-base: <a href="https://github.com/QiliangFan/vecro-base">https://github.com/QiliangFan/vecro-base</a></li><li>vecro-mongodb: <a href="https://github.com/QiliangFan/vecro-mongodb">https://github.com/QiliangFan/vecro-mongodb</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/etigerstudio/vecro-base<br><span class="hljs-built_in">cd</span> vecro-base<br>GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o vecro-base .<br>docker build . -t fanqiliang/vecro-base:v1<br><span class="hljs-comment"># 或者这样，就不用push和改名了</span><br>minikube image build -t vecro-base:v1 .<br></code></pre></td></tr></table></figure><blockquote><p>！！！！ 注意，请勿使用latest的mongo镜像，必然会失败！经过测试，mongo:4.2可正常运行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/etigerstudio/vecro-mongodb<br><span class="hljs-built_in">cd</span> vecro-mongodb<br>GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o vecro-mongodb .<br>docker build . -t fanqiliangvecro-mongodb:v1 <br><span class="hljs-comment"># 或者这样，就不用push和改名了</span><br>minikube image build -t vecro-mongodb:v1 .<br></code></pre></td></tr></table></figure><blockquote><p>这里我已经build好并且把镜像上传了，大家要使用的话只需要加个前缀<code>fanqiliang/</code>或者直接使用我fork的仓库。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker login<br>docker push fanqiliang/vecro-base:v1<br>docker push fanqiliang/vecro-mongodb:v1 <br></code></pre></td></tr></table></figure><h2 id="24-部署monitoring-infrastructure"><a class="markdownIt-Anchor" href="#24-部署monitoring-infrastructure"></a> 2.4 部署monitoring infrastructure:</h2><blockquote><p>进入VECROsim源码根目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> metrics/setup/ <br>sh ./setup.sh<br></code></pre></td></tr></table></figure><h2 id="25-部署microservice-system"><a class="markdownIt-Anchor" href="#25-部署microservice-system"></a> 2.5 部署microservice system:</h2><blockquote><p>进入VECROsim源码根目录</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> deploy<br>kubectl create namespace social<br>kubectl create configmap mongo-initjs -n social --from-file=mongo-init.js<br><span class="hljs-comment"># Deploy Social system in the cluster</span><br>go run . -deffile base/social.yaml<br><span class="hljs-comment"># Install Prometheus monitor for Social system</span><br>kubectl create namespace monitoring<br>kubectl apply -f base/social-monitor.yaml<br></code></pre></td></tr></table></figure><blockquote><p>注意，如果pod镜像拉取失败，如果想要删除pod可以这样，pod会自动重新生成</p><p><code>kubectl delete pods --all -n social</code></p><p>如果想要彻底删除这些pod只需要删除对应namespace即可</p><p><code>kubectl delete namespace social</code></p><p>如果想立即强制kill并删除容器可以这样<br /><code>kubectl delete pods --all -n social --force --grace-period=0</code></p></blockquote><p>有时是mongo镜像拉取失败，可以进入虚拟机拉取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube ssh docker pull mongo<br></code></pre></td></tr></table></figure><h2 id="25-施加负载"><a class="markdownIt-Anchor" href="#25-施加负载"></a> 2.5 施加负载:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Make &#x27;text&#x27; service accessible at http://localhost:8080</span><br><span class="hljs-built_in">cd</span> ./load<br>kubectl port-forward -n social svc/social-text 8080:80 &gt; /dev/null &amp; <br>go run . -delay 100ms -duration 2h -<span class="hljs-built_in">users</span> 5 -url <span class="hljs-string">&quot;http://localhost:8080&quot;</span><br></code></pre></td></tr></table></figure><h2 id="26-注入故障"><a class="markdownIt-Anchor" href="#26-注入故障"></a> 2.6 注入故障：</h2><blockquote><p>Inject the a network delay fault (3 minutes 500ms network delay to service posts-storage) to the system.</p></blockquote><p>在注入故障过程中，作者借用了<a href="https://chaos-mesh.org/zh/docs/quick-start/">chaos-mesh工具</a>, 这个工具是专门用来模拟微服务中故障注入的。 因此需要先安装chaos-mesh，推荐使用helm安装chaos-mesh: <a href="https://chaos-mesh.org/docs/production-installation-using-helm/">https://chaos-mesh.org/docs/production-installation-using-helm/</a></p><blockquote><p>注意，如果helm安装chaos-mesh后pod启动失败，极有可能是网络不好。在搭建过程中我就反复失败，但是网络环境好时，就一下成功了。 （注意，特别需要设置好vpn~）</p><p>如果是因为拉取镜像失败，可以提前拉取：<code>minikube ssh docker pull ghcr.io/chaos-mesh/chaos-mesh:v2.5.0</code></p><p>可以通过反复卸载安装chaos-mesh来重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm uninstall chaos-mesh -n chaos-mesh<br>helm install chaos-mesh chaos-mesh/chaos-mesh -n=chaos-mesh<br></code></pre></td></tr></table></figure><p>或者这样重启：<code>kubectl rollout restart deployment/chaos-controller-manager -n chaos-mesh</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Inject network delay fault to the deployed system</span><br>kubectl apply -f ./inject/social-delay.yaml <br></code></pre></td></tr></table></figure><h2 id="27-获取数据"><a class="markdownIt-Anchor" href="#27-获取数据"></a> 2.7 获取数据：</h2><blockquote><p>开放端口：</p></blockquote><blockquote><p>参考：<a href="https://blog.marcnuri.com/prometheus-grafana-setup-minikube">https://blog.marcnuri.com/prometheus-grafana-setup-minikube</a></p></blockquote><h3 id="271-grafana"><a class="markdownIt-Anchor" href="#271-grafana"></a> 2.7.1： Grafana</h3><blockquote><p>其实这个没必要.</p></blockquote><p>用户/密码都是<code>admin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl expose service grafana -n simple --<span class="hljs-built_in">type</span>=NodePort --target-port=3000 --name=grafana-np<br>minikube service grafana-np -n simple<br><span class="hljs-comment"># kubectl delete service grafana-np -n simple</span><br></code></pre></td></tr></table></figure><h3 id="272-promethues"><a class="markdownIt-Anchor" href="#272-promethues"></a> 2.7.2: Promethues</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl expose service prometheus-k8s -n simple --<span class="hljs-built_in">type</span>=NodePort --target-port=9090 --name=prometheus-np<br>minikube service prometheus-np -n simple<br></code></pre></td></tr></table></figure><p>然后prometheus就会输出url，访问url就能获取指标了，这也是后面python脚本需要修改的地方：</p><blockquote><p>这里部署了两个prometheus服务，所有有两</p></blockquote><table><thead><tr><th>NAMESPACE</th><th>NAME</th><th>TARGET PORT</th><th>URL</th></tr></thead><tbody><tr><td>simple</td><td>prometheus-np</td><td>port-1/9090</td><td><a href="http://192.168.49.2:32165">http://192.168.49.2:32165</a></td></tr><tr><td></td><td></td><td>port-2/8080</td><td><a href="http://192.168.49.2:32261">http://192.168.49.2:32261</a></td></tr></tbody></table><blockquote><p>⚠️ vecrosim获取的指标都是在vecro-base中自定义的指标，因此需要了解Prometheus通过编程自定义指标的方式。</p></blockquote><blockquote><p>有一个小问题，minikube虚拟机创建时时区是UTC+0,和主机的时区不同导致时间不一样，因此需要更改系统时区。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cd metrics/<br>python3 collect_social.py<br></code></pre></td></tr></table></figure><p>有一些参数需要配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># url 在暴露端口时minikube service会输出prometheus的ip和端口</span><br>prometheus_host_url = <span class="hljs-string">&quot;http://127.0.0.1:9091/&quot;</span><br>start_time = parse_datetime(<span class="hljs-string">&quot;2022-05-22 21:00:00&quot;</span>)<br>end_time = parse_datetime(<span class="hljs-string">&quot;2022-05-22 22:00:00&quot;</span>)<br>step = <span class="hljs-string">&quot;60s&quot;</span><br>filepath = <span class="hljs-string">&quot;social-delay/jitter_high&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-相关资料&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-相关资料&quot;&gt;&lt;/a&gt; 1. 相关资料：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;代码仓库：&lt;a href=&quot;https://github.com/etigerstudio/VECROs</summary>
      
    
    
    
    <category term="环境搭建" scheme="https://www.torch-fan.site/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建Google OnlineBoutique流程</title>
    <link href="https://www.torch-fan.site/2022/12/26/%E6%90%AD%E5%BB%BAGoogle-OnlineBoutique%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.torch-fan.site/2022/12/26/%E6%90%AD%E5%BB%BAGoogle-OnlineBoutique%E6%B5%81%E7%A8%8B/</id>
    <published>2022-12-26T03:07:52.000Z</published>
    <updated>2023-02-08T04:59:31.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-资料准备"><a class="markdownIt-Anchor" href="#1-资料准备"></a> 1. 资料准备：</h1><ul><li>OnlineBoutique仓库地址：<a href="https://github.com/GoogleCloudPlatform/microservices-demo">https://github.com/GoogleCloudPlatform/microservices-demo</a></li><li>部署文档：<a href="https://github.com/GoogleCloudPlatform/microservices-demo/blob/main/docs/development-guide.md">https://github.com/GoogleCloudPlatform/microservices-demo/blob/main/docs/development-guide.md</a></li><li>安装Helm（The package manager for Kubernetes）：<a href="https://helm.sh/">https://helm.sh/</a></li><li>为minikube安装prometheus和grafana：<a href="https://blog.marcnuri.com/prometheus-grafana-setup-minikube">https://blog.marcnuri.com/prometheus-grafana-setup-minikube</a></li></ul><h1 id="2-环境准备"><a class="markdownIt-Anchor" href="#2-环境准备"></a> 2. 环境准备：</h1><h2 id="21-docker-engine"><a class="markdownIt-Anchor" href="#21-docker-engine"></a> 2.1 Docker engine：</h2><p>Document：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br>sudo <span class="hljs-built_in">mkdir</span> -p /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br>sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure><h2 id="22-kubectl"><a class="markdownIt-Anchor" href="#22-kubectl"></a> 2.2 kubectl:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO <span class="hljs-string">&quot;https://dl.k8s.io/release/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span><br>sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl<br>kubectl version --client --output=yaml<br></code></pre></td></tr></table></figure><h2 id="23-skaffold-20"><a class="markdownIt-Anchor" href="#23-skaffold-20"></a> 2.3 skaffold (2.0+):</h2><p><a href="https://skaffold.dev/docs/install/">https://skaffold.dev/docs/install/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># For Linux x86_64 (amd64)</span><br>curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64 &amp;&amp; \<br>sudo install skaffold /usr/local/bin/<br>skaffold version<br></code></pre></td></tr></table></figure><h2 id="24-minikube"><a class="markdownIt-Anchor" href="#24-minikube"></a> 2.4 minikube:</h2><p><a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64<br>sudo install minikube-linux-amd64 /usr/local/bin/minikube<br>minikube version<br></code></pre></td></tr></table></figure><h2 id="25-kind"><a class="markdownIt-Anchor" href="#25-kind"></a> 2.5 kind:</h2><p><a href="https://kind.sigs.k8s.io/docs/user/quick-start">https://kind.sigs.k8s.io/docs/user/quick-start</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64<br><span class="hljs-built_in">chmod</span> +x ./kind<br>sudo <span class="hljs-built_in">mv</span> ./kind /usr/local/bin/kind<br>kind --version<br></code></pre></td></tr></table></figure><h1 id="3-创建集群"><a class="markdownIt-Anchor" href="#3-创建集群"></a> 3. 创建集群：</h1><blockquote><p>注意，创建集群时，务必连接VPN，否则会超时. 代理的配置请见笔记：<a href="https://www.torch-fan.site/2022/07/20/Ubuntu%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/">Ubuntu下配置代理</a></p><p><code>minikube start --docker-env http_proxy=http://127.0.0.1:7890 --docker-env https_proxy=http://127.0.0.1:7890 --docker-env no_proxy=localhost,127.0.0.1,10.96.0.0/12,192.168.99.0/24,192.168.39.0/24</code></p></blockquote><blockquote><p>机器配置</p><p>4 CPUs</p><p>4.0 GiB memory</p><p>32 GB disk space</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果使用代理 (只有第一次拉镜像需要vpn)</span><br>minikube start --docker-env http_proxy=192.168.8.2:7890 --docker-env https_proxy=192.168.8.2:7890 --docker-env no_proxy=localhost,127.0.0.1,10.96.0.0/12,192.168.0.1/16,192.168.49.2 --cpus=4 --memory 4096 --disk-size 32g<br><br>minikube start --cpus=4 --memory 4096 --disk-size 32g<br></code></pre></td></tr></table></figure><blockquote><p>查看是否连上了控制面板</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get nodes<br></code></pre></td></tr></table></figure><blockquote><p>运行集群</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">skaffold run<br><span class="hljs-comment"># 这一步仍然需要VPN</span><br><span class="hljs-built_in">export</span> http_proxy=192.168.8.2:7890<br><span class="hljs-built_in">export</span> https_proxy=192.168.8.2:7890<br><span class="hljs-built_in">export</span> no_proxy=<span class="hljs-string">&quot;localhost,127.0.0.1,10.96.0.0/12,192.168.0.1/16,192.168.49.2&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>获取所有pods</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods<br></code></pre></td></tr></table></figure><blockquote><p>清理</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">skaffold delete<br></code></pre></td></tr></table></figure><h1 id="4-收集指标"><a class="markdownIt-Anchor" href="#4-收集指标"></a> 4. 收集指标</h1><blockquote><p>安装Prometheus</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo snap install helm --classic<br>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts<br>helm install prometheus prometheus-community/prometheus<br>kubectl expose service prometheus-server --<span class="hljs-built_in">type</span>=NodePort --target-port=9090 --name=prometheus-server-np<br><span class="hljs-comment"># 开放prometheus的端口，可供外部访问, 并自动打开浏览器访问</span><br>minikube service prometheus-server-np<br></code></pre></td></tr></table></figure><blockquote><p>安装Grafana</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm repo add grafana https://grafana.github.io/helm-charts<br>helm install grafana grafana/grafana<br>kubectl expose service grafana --<span class="hljs-built_in">type</span>=NodePort --target-port=3000 --name=grafana-np<br><span class="hljs-comment"># 这一行打印账号“admin”的密码，需要记住！</span><br>kubectl get secret --namespace default grafana -o jsonpath=<span class="hljs-string">&quot;&#123;.data.admin-password&#125;&quot;</span> | <span class="hljs-built_in">base64</span> --decode ; <span class="hljs-built_in">echo</span><br><span class="hljs-comment"># 开放Grafana的端口，可供外部访问, 并自动打开浏览器访问</span><br>minikube service grafana-np<br></code></pre></td></tr></table></figure><p>需要在Grafana中配置来自Prometheus的datasource，就可以创建pane进行可视化，并且导出数据了。但是这里仍然不包含fault injection的部分，需要找一个合适的故障注入工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-资料准备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-资料准备&quot;&gt;&lt;/a&gt; 1. 资料准备：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;OnlineBoutique仓库地址：&lt;a href=&quot;https://github.com/Googl</summary>
      
    
    
    
    <category term="环境搭建" scheme="https://www.torch-fan.site/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu使用EasyConnect连接学校服务器</title>
    <link href="https://www.torch-fan.site/2022/11/26/Ubuntu%E4%BD%BF%E7%94%A8EasyConnect%E8%BF%9E%E6%8E%A5%E5%AD%A6%E6%A0%A1%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://www.torch-fan.site/2022/11/26/Ubuntu%E4%BD%BF%E7%94%A8EasyConnect%E8%BF%9E%E6%8E%A5%E5%AD%A6%E6%A0%A1%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2022-11-26T07:02:34.000Z</published>
    <updated>2022-11-29T09:23:44.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>EasyConnect是知名的流氓软件，如果不了解可以搜索“流氓软件 EasyConnect”，想在Linux下安全使用可以遵循这篇</p></blockquote><h1 id="1-准备"><a class="markdownIt-Anchor" href="#1-准备"></a> 1. 准备：</h1><blockquote><p>注意安装Docker一定要配置好用户组权限，不然在后续步骤会出现一系列问题</p></blockquote><ul><li>首先安装Docker（记得配置好用户组权限）</li><li>使用docker-easyconnect: <a href="https://github.com/Hagb/docker-easyconnect">https://github.com/Hagb/docker-easyconnect</a></li></ul><h1 id="2-使用方法"><a class="markdownIt-Anchor" href="#2-使用方法"></a> 2. 使用方法：</h1><blockquote><p>如果只需要创建临时容器，可以加上–rm</p><p>退出后可以用<code>docker start -ai &lt;container&gt;</code> 重新启动一下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --device /dev/net/tun --cap-add NET_ADMIN -ti -p 127.0.0.1:1080:1080 -p 127.0.0.1:8888:8888 -e EC_VER=7.6.3 -e CLI_OPTS=<span class="hljs-string">&quot;-d vpnaddress -u username -p password&quot;</span> hagb/docker-easyconnect:cli<br></code></pre></td></tr></table></figure><p>如果要连接NK的VPN：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">STUID=&lt;学号&gt;<br>PASSWD=&lt;密码&gt;<br>docker run --name ec --device /dev/net/tun --cap-add NET_ADMIN -ti -p 127.0.0.1:1080:1080 -p 127.0.0.1:8888:8888 -e EC_VER=7.6.3 -e CLI_OPTS=<span class="hljs-string">&quot;-d https://vpn.nankai.edu.cn -u <span class="hljs-variable">$STUID</span> -p <span class="hljs-variable">$PASSWD</span>&quot;</span> hagb/docker-easyconnect:cli<br></code></pre></td></tr></table></figure><h1 id="3-设置代理"><a class="markdownIt-Anchor" href="#3-设置代理"></a> 3. 设置代理：</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&quot;127.0.0.1:8888&quot;</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&quot;127.0.0.1:8888&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;EasyConnect是知名的流氓软件，如果不了解可以搜索“流氓软件 EasyConnect”，想在Linux下安全使用可以遵循这篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-准备&quot;&gt;&lt;a class=&quot;markdownIt-Anch</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    <category term="Ubuntu" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu/"/>
    
    
    <category term="南开" scheme="https://www.torch-fan.site/tags/%E5%8D%97%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>Mac 清理垃圾</title>
    <link href="https://www.torch-fan.site/2022/09/29/Mac-%E6%B8%85%E7%90%86%E5%9E%83%E5%9C%BE/"/>
    <id>https://www.torch-fan.site/2022/09/29/Mac-%E6%B8%85%E7%90%86%E5%9E%83%E5%9C%BE/</id>
    <published>2022-09-29T01:12:48.000Z</published>
    <updated>2022-11-15T02:27:36.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-清理日志文件"><a class="markdownIt-Anchor" href="#1-清理日志文件"></a> 1 清理日志文件:</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 不是很推荐把log文件夹给删除, 删除内容就行</span><br>sudo <span class="hljs-built_in">rm</span> -rf /private/var/log/*<br>sudo <span class="hljs-built_in">rm</span> -rf /private/var/logs/*<br></code></pre></td></tr></table></figure><h1 id="2-清理临时文件和缓存文件"><a class="markdownIt-Anchor" href="#2-清理临时文件和缓存文件"></a> 2 清理临时文件和缓存文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> -rf /private/var/tmp/*<br><br>sudo <span class="hljs-built_in">rm</span> -rf ~/Library/Caches/*<br></code></pre></td></tr></table></figure><h1 id="3-删除本机的时间机器备份注意-不是指时间机器备份硬盘"><a class="markdownIt-Anchor" href="#3-删除本机的时间机器备份注意-不是指时间机器备份硬盘"></a> 3 删除本机的时间机器备份(注意, 不是指时间机器备份硬盘)</h1><blockquote><p>Mac OS 除了用硬盘搞时间机器备份, 他自己还会搞一份备份</p><p>删除时间机器缓存最节省空间的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出本机上所有本地时间机器缓存</span><br>sudo tmutil listlocalsnapshots /<br><br><span class="hljs-comment"># 删除指定的时间机器备份缓存(可以多出很多~, 系统文件大部分都是这些搞的备份)</span><br>tmutil deletelocalsnapshots 2022-09-28-105624<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-清理日志文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-清理日志文件&quot;&gt;&lt;/a&gt; 1 清理日志文件:&lt;/h1&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="收藏" scheme="https://www.torch-fan.site/categories/%E6%94%B6%E8%97%8F/"/>
    
    
    <category term="Mac OS" scheme="https://www.torch-fan.site/tags/Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>vscode连接虚拟机小贴士</title>
    <link href="https://www.torch-fan.site/2022/09/23/vscode%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    <id>https://www.torch-fan.site/2022/09/23/vscode%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%8F%E8%B4%B4%E5%A3%AB/</id>
    <published>2022-09-23T11:09:38.000Z</published>
    <updated>2022-11-15T02:27:36.105Z</updated>
    
    <content type="html"><![CDATA[<p>谈到vscode连接虚拟机, 很多人第一想到桥接模式, 但是对于wifi网卡, 现阶段似乎无法实现,如果对wifi网卡使用桥接, 客户机将没有网络, 还表现为没有路由和ipv4地址, 因此这篇笔记主要是为那些使用笔记本(拥有无线网卡)的同学准备.</p><h1 id="1-准备工作"><a class="markdownIt-Anchor" href="#1-准备工作"></a> 1. 准备工作:</h1><p>创建一个NAT网络的虚拟机.</p><h1 id="2-配置端口映射"><a class="markdownIt-Anchor" href="#2-配置端口映射"></a> 2. 配置端口映射:</h1><p>在NAT模式下, 客户机的IP是不被感知的, 为了能够方便的访问到客户机, 我们进行端口映射(有时也叫NAT映射).</p><p>思路: 我们可以在virtual box中将<code>宿主机的端口</code>映射到<code>客户机的端口</code>:</p><p>假设我们有客户机IP: <code>10.0.2.15</code></p><p><img src="https://s1.ax1x.com/2022/09/23/xkXQaR.jpg" alt="客户机IP" /></p><p>我们设立如下的端口映射:</p><table><thead><tr><th style="text-align:center">Host</th><th style="text-align:center">Guest</th></tr></thead><tbody><tr><td style="text-align:center">127.0.0.1:22</td><td style="text-align:center">10.0.2.15:22</td></tr></tbody></table><blockquote><p>下图中配置的映射是 127.0.0.1:2233 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 10.0.2.15:22, 但是为了方便, 推荐将主机端口换为22, 这样连接时就不用额外的参数,至于端口冲突,最后一节给出解决思路.</p></blockquote><p><img src="https://s1.ax1x.com/2022/09/23/xkX3Px.jpg" alt="端口映射" /></p><h1 id="3-访问客户机"><a class="markdownIt-Anchor" href="#3-访问客户机"></a> 3. 访问客户机:</h1><p>如果我们需要SSH到客户机, 一般想的可能是直接ssh: <code>ssh guest_user@&lt;guest_ip&gt;</code>, 但是NAT情况下IP是不感知的, 因此无法访问, 但是我们做端口映射之后, 就变了, 我们可以通过这种方式访问客户机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh guest_user@127.0.0.1 <span class="hljs-comment"># 事实上, 他是ssh到客户机上, 登陆用户名为guest_user</span><br></code></pre></td></tr></table></figure><p>随后如果想使用vscode, 像往常一样即可.</p><h1 id="4-其他"><a class="markdownIt-Anchor" href="#4-其他"></a> 4. 其他:</h1><p>上文我们讲到, 将本机的22端口映射到客户机的22端口, 但是本机的22端口并不总是空闲的, 为此我们可能将2233端口映射到客户机的22端口, 访问方式就变化了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -p 2233 guest_user@127.0.0.1<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;谈到vscode连接虚拟机, 很多人第一想到桥接模式, 但是对于wifi网卡, 现阶段似乎无法实现,如果对wifi网卡使用桥接, 客户机将没有网络, 还表现为没有路由和ipv4地址, 因此这篇笔记主要是为那些使用笔记本(拥有无线网卡)的同学准备.&lt;/p&gt;
&lt;h1 id=&quot;1</summary>
      
    
    
    
    <category term="收藏" scheme="https://www.torch-fan.site/categories/%E6%94%B6%E8%97%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>CMU Bomblab(汇编小笔记)</title>
    <link href="https://www.torch-fan.site/2022/09/22/CMU-Bomblab-%E6%B1%87%E7%BC%96%E5%B0%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.torch-fan.site/2022/09/22/CMU-Bomblab-%E6%B1%87%E7%BC%96%E5%B0%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2022-09-22T09:59:06.000Z</published>
    <updated>2022-11-15T02:27:36.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://github.com/CurryTang/bomb_lab_solution">https://github.com/CurryTang/bomb_lab_solution</a></p></blockquote><blockquote><p>以下从x64架构为准</p></blockquote><h1 id="1-相关指令"><a class="markdownIt-Anchor" href="#1-相关指令"></a> 1. 相关指令:</h1><h2 id="11-objdump-用于给出所有汇编指令"><a class="markdownIt-Anchor" href="#11-objdump-用于给出所有汇编指令"></a> 1.1 objdump: 用于给出所有汇编指令</h2><blockquote><p>objdump -d</p><p><code>Display assembler contents of executable sections</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d xxx &gt; xxx.asm<br></code></pre></td></tr></table></figure><h2 id="12-gdb"><a class="markdownIt-Anchor" href="#12-gdb"></a> 1.2 gdb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb &lt;program&gt; <span class="hljs-comment"># 调试程序</span><br>p &lt;var&gt;  <span class="hljs-comment"># 打印变量</span><br>b &lt;func&gt;  <span class="hljs-comment"># 给函数设置端点</span><br>c <span class="hljs-comment"># continue</span><br>n <span class="hljs-comment"># next line, stepping over function calls</span><br>s <span class="hljs-comment"># next line, stepping into funciton calls</span><br>list <span class="hljs-comment"># 展开源程序代码</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">p/c *0x2000@10 <span class="hljs-comment"># 查看内存字符值</span><br>x /25c 0x2000  <span class="hljs-comment"># x本身就是看内存的, 不需要加*</span><br><br>p/x <span class="hljs-variable">$eax</span> <span class="hljs-comment"># 查看寄存器值的8进制形式</span><br><br>x /20a 0x2000<br></code></pre></td></tr></table></figure><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十六进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示变量。</p><p>c 按字符格式显示变量。</p><p>f 按浮点数格式显示变量。</p><p>切换栈帧:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bt</span><br><br><span class="hljs-attribute">f</span><span class="hljs-meta"> [N]</span><br></code></pre></td></tr></table></figure><p>显示所有寄存器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span> registers<br></code></pre></td></tr></table></figure><p>看寄存器的值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> /<span class="hljs-number">16</span>xb $eax+<span class="hljs-number">0</span>x14<br></code></pre></td></tr></table></figure><h2 id="13-strings"><a class="markdownIt-Anchor" href="#13-strings"></a> 1.3 strings</h2><p>如果从汇编中看到某些关键字符, 可以这样获取一整句话:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">strings bomb | grep keywords<br></code></pre></td></tr></table></figure><h1 id="2-bomblab实验操作"><a class="markdownIt-Anchor" href="#2-bomblab实验操作"></a> 2. Bomblab实验操作</h1><ol><li>开启汇编窗口(好查看对应的汇编代码)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">layout asm<br></code></pre></td></tr></table></figure><ol start="2"><li>打断点</li></ol><p>在进每个阶段前且在readline前打断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">b *0x400e37 <span class="hljs-comment"># 地址\指针前要有 *</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">b phase_1<br>b phase_2<br>b phase_3<br>b phase_4<br>b phase_5<br>b phase_6<br></code></pre></td></tr></table></figure><ol start="3"><li>开始运行,进行调试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">r<br><br><span class="hljs-comment"># 查看某一个地址/函数的汇编 (如果不在运行没法根据地址看汇编, 只能用函数名名字)</span><br>disassem *0x400ee0<br><br>disassem phase_1<br><br>disassem strings_not_equal<br></code></pre></td></tr></table></figure><h1 id="3-看汇编"><a class="markdownIt-Anchor" href="#3-看汇编"></a> 3. 看汇编</h1><p>x86系统中,栈的地址是从高地址往低地址, push栈帧的时候, rsp(<code>stack pointer</code>)减少四个字节.</p><p><img src="https://s1.328888.xyz/2022/09/22/IoR1S.png" alt="寄存器" /></p><h2 id="31-通用寄存器64位寄存器"><a class="markdownIt-Anchor" href="#31-通用寄存器64位寄存器"></a> 3.1 通用寄存器(64位寄存器)</h2><p>0x8(%rsp) 表示上一个变量(一般第一个)</p><blockquote><p>bomb中将string_length的返回值放在EAX中</p></blockquote><p>EAX: accumulator, 加法乘法指令的缺省寄存器<br />EBX: base基地址寄存器,在内存寻址时存放基地址<br />ECX: counter计数器, 重复(REP)前缀指令和LOOP指令的内定计数器<br />EDX: 存放整数除法产生的余数<br />ESI/EDI: source/destination index, 字符串操作指令里, DS:ESI指向源串, ES:EDI指向目标串<br />EBP: base pointer, 高级语言函数调用时的frame pointer保存地方<br />如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">push ebp;  // 保存当前ebp<br>mov ebp,esp; // ebp设为当前<br>sub esp,xxx;  // 预留xxx字节给函数临时变量<br></code></pre></td></tr></table></figure><p>ESP: 专门用作堆栈的顶部指针</p><h2 id="32-其他寄存器"><a class="markdownIt-Anchor" href="#32-其他寄存器"></a> 3.2 其他寄存器:</h2><p>R0~R12 是64位工作寄存器, 其中R12有可能被linker修改,所以函数开头经常对R12进行保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">push %r12 <span class="hljs-comment"># 将R12的内容推入堆栈进行保护</span><br></code></pre></td></tr></table></figure><p>当函数参数少于7个时, 从左到右参数依次放入寄存器:</p><ul><li>rdi</li><li>rsi</li><li>rdx</li><li>rcx</li><li>r8</li><li>r9</li></ul><h2 id="33-条件跳转指令和比较指令"><a class="markdownIt-Anchor" href="#33-条件跳转指令和比较指令"></a> 3.3 条件跳转指令和比较指令:</h2><blockquote><p><a href="https://faydoc.tripod.com/cpu/jle.htm">https://faydoc.tripod.com/cpu/jle.htm</a></p></blockquote><p><code>test</code> 指令主要将两个操作数按位与, 并根据结果设置<code>标志寄存器</code> (结果不会写回到目标操作数), <code>test</code>的两个寄存器只有都是空(全0)时或者不同时, ZF才会被置位</p><blockquote><p>注意: addq src, dst -&gt; dst = dst + src, 会将结果写回到目标寄存器上</p></blockquote><p><code>test</code>指令位与运算结果为0的话, ZF(Zero Flag)设为0.</p><p><code>je</code> 是jz(jump if zero)的别称.<br /><code>jne</code>就是反过来的条件跳转指令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cmp</span> eax, edx<br>ja somewhere ; <span class="hljs-attribute">will</span> go <span class="hljs-string">&quot;somewhere&quot;</span> if eax &gt;u edx<br>             ; <span class="hljs-attribute">where</span> &gt;u is <span class="hljs-string">&quot;unsigned greater than&quot;</span><br><br>cmp eax, edx<br>jg somewhere ; <span class="hljs-attribute">will</span> go <span class="hljs-string">&quot;somewhere&quot;</span> if eax &gt;s edx<br>             ; <span class="hljs-attribute">where</span> &gt;s is <span class="hljs-string">&quot;signed greater than&quot;</span><br></code></pre></td></tr></table></figure><p><code>cmpb</code>: 判断是否相等, 然后置ZF为1:</p><p><code>cmpl</code>:<br />For &gt;, there is ja for unsigned and jg for signed (jump if above and jump if greater).</p><pre><code class="hljs">For &lt;, there is jb for unsigned and jl for signed (jump if below and jump if less).</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmpb <span class="hljs-variable">$0x0</span>, (%edx)<br></code></pre></td></tr></table></figure><p><code>(%edx)</code> 表示 %edx中所保存的地址指向单元的内容(即取指针所指内容)</p><h2 id="34-寄存器操作"><a class="markdownIt-Anchor" href="#34-寄存器操作"></a> 3.4 寄存器操作:</h2><blockquote><p><a href="https://stackoverflow.com/questions/19748074/meaning-of-0x8rsp">https://stackoverflow.com/questions/19748074/meaning-of-0x8rsp</a></p></blockquote><p><code>0x8(%rsp)</code> means &quot;get the location on the stack that is 8 bytes away from the stack pointer %rsp</p><p><code>lea</code>: 和mov很像, 不过有其他作用</p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他:</h1><p>因为不同同学的bomb内容不同, 我帮的一位同学比网上的版本要稍微复杂一些,共计19小时,bingo~</p><p>这篇笔记只是零星随笔, 帮助自己回忆汇编, 日后有机会会综合整理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://github.com/CurryTang/bomb_lab_solution&quot;&gt;https://github.com/CurryTang/bomb_lab_solution&lt;/a&gt;&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="操作系统" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    <category term="汇编" scheme="https://www.torch-fan.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E6%B1%87%E7%BC%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Generate 204链接收集</title>
    <link href="https://www.torch-fan.site/2022/09/04/Generate-204%E9%93%BE%E6%8E%A5%E6%94%B6%E9%9B%86/"/>
    <id>https://www.torch-fan.site/2022/09/04/Generate-204%E9%93%BE%E6%8E%A5%E6%94%B6%E9%9B%86/</id>
    <published>2022-09-04T04:39:15.000Z</published>
    <updated>2022-11-15T02:27:36.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意, 这些链接都可以用https替代, 但是并不推荐.</p></blockquote><ul><li><a href="http://www.gstatic.com/generate_204">http://www.gstatic.com/generate_204</a></li><li><a href="http://cp.cloudflare.com/generate_204">http://cp.cloudflare.com/generate_204</a></li><li><a href="http://www.qualcomm.cn/generate_204">http://www.qualcomm.cn/generate_204</a></li><li><a href="http://clients3.google.com/generate_204">http://clients3.google.com/generate_204</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注意, 这些链接都可以用https替代, 但是并不推荐.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gstatic.com/generate_204&quot;&gt;http://www.gstatic.com</summary>
      
    
    
    
    <category term="收藏" scheme="https://www.torch-fan.site/categories/%E6%94%B6%E8%97%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>dbs结项报告</title>
    <link href="https://www.torch-fan.site/2022/09/03/dbs%E7%BB%93%E9%A1%B9%E6%8A%A5%E5%91%8A/"/>
    <id>https://www.torch-fan.site/2022/09/03/dbs%E7%BB%93%E9%A1%B9%E6%8A%A5%E5%91%8A/</id>
    <published>2022-09-03T08:24:39.000Z</published>
    <updated>2022-11-15T02:27:36.104Z</updated>
    
    <content type="html"><![CDATA[<center>    <font size="10"><bold>使用命令行参数启动微型虚拟机</bold></font>    <br/><br/></center><h1 id="1-项目实现方案研究"><a class="markdownIt-Anchor" href="#1-项目实现方案研究"></a> 1. 📽 项目实现方案研究:</h1><blockquote><p>实现方案给出是为了提供<font color="cyan">可复现性</font></p></blockquote><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td>处理器</td><td>AMD® Ryzen 7 4800h with radeon graphics × 16</td></tr><tr><td>内存</td><td>32g</td></tr><tr><td>显卡</td><td>NVIDIA Corporation TU117M [GeForce GTX 1650 Ti Mobile] / NVIDIA GeForce GTX 1650 Ti/PCIe/SSE2</td></tr><tr><td>OS</td><td>Ubuntu 22.04 LTS</td></tr><tr><td>rustc版本</td><td>rustc 1.62.1</td></tr></tbody></table><h2 id="11-参考目标-firecracker"><a class="markdownIt-Anchor" href="#11-参考目标-firecracker"></a> 1.1 🎲 参考目标: <a href="https://github.com/firecracker-microvm/firecracker">firecracker</a></h2><h3 id="111-构建firecracker"><a class="markdownIt-Anchor" href="#111-构建firecracker"></a> 1.1.1 构建<code>firecracker</code></h3><blockquote><p>cargo的使用文档: <a href="https://doc.rust-lang.org/cargo/index.html">https://doc.rust-lang.org/cargo/index.html</a></p><p>如果需要编译其他平台的crate, 可能还需要用rustup添加对应的toolchain, rustup的使用文档: <a href="https://rust-lang.github.io/rustup/index.html">https://rust-lang.github.io/rustup/index.html</a></p></blockquote><ol><li>拉取源码:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/firecracker-microvm/firecracker<br><span class="hljs-built_in">cd</span> firecracker<br></code></pre></td></tr></table></figure><ol start="2"><li><p>配置依赖</p><blockquote><p>构建firecraker依赖于<code>Docker</code>, 我的个人博客上docker的安装笔记可供参考: <a href="https://www.torch-fan.site/2022/07/21/Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker/">Ubuntu上使用Docker</a></p></blockquote></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install build-essential clang<br>cargo check <br></code></pre></td></tr></table></figure><ol start="3"><li>构建firecracker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">tools/devtool build<br><br><span class="hljs-comment"># release</span><br>tools/devtool build --release<br></code></pre></td></tr></table></figure><h3 id="112-使用firecracker创建虚拟机"><a class="markdownIt-Anchor" href="#112-使用firecracker创建虚拟机"></a> 1.1.2 使用<code>firecracker</code>创建虚拟机</h3><blockquote><p>参考资料: <a href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/getting-started.md">https://github.com/firecracker-microvm/firecracker/blob/main/docs/getting-started.md</a></p></blockquote><blockquote><p>事实上, 报告的最终目的目的并不在于描述构建firecraker或者使用dbs之类的方式, 而是借助对firecraker的了解来辅助使用命令行参数从<code>DBS</code>中启动一个虚拟机, 因此文档叙述不以线性进行, 将进行跳转, 体现思考的过程.</p></blockquote><p>​使用firecracker创建虚拟机, 需要这些内容:</p><ol><li><code>API socket</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./firecracker --api-sock /tmp/firecracker.socket<br></code></pre></td></tr></table></figure><ol start="2"><li><p><code>Linux kernel</code></p></li><li><p><code>rootfs</code></p></li></ol><p>​因此当我们开始了解<code>DBS</code>时, 需要关注<code>DBS</code>已经具备和不具备的要素,</p><h2 id="12-更进一步"><a class="markdownIt-Anchor" href="#12-更进一步"></a> 1.2 🦌 更进一步</h2><blockquote><p>上面的步骤不存在任何困难, 但我们并不关心是否创建好虚拟机, 而关注在firecracker一开始是如何创建一个虚拟机</p></blockquote><h3 id="121-vmm的对外接口"><a class="markdownIt-Anchor" href="#121-vmm的对外接口"></a> 1.2.1 VMM的对外接口</h3><blockquote><p>定位到<code>src/firecracker/src/main.rs</code>, 关注在<code>api-sock</code>命令行参数</p></blockquote><p>firecracker对虚拟机进行配置主要分为<font color="cyan"><strong>两种形式</strong></font>:</p><ol><li>HTTP API的请求方式进行配置(也可以同时指定配置文件)</li><li>通过指定配置文件的方式进行配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">rootfs_path=$(<span class="hljs-built_in">pwd</span>)<span class="hljs-string">&quot;/hello-rootfs.ext4&quot;</span><br>curl --unix-socket /tmp/firecracker.socket -i \<br>  -X PUT <span class="hljs-string">&#x27;http://localhost/drives/rootfs&#x27;</span> \<br>  -H <span class="hljs-string">&#x27;Accept: application/json&#x27;</span>           \<br>  -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span>     \<br>  -d <span class="hljs-string">&quot;&#123;</span><br><span class="hljs-string">        \&quot;drive_id\&quot;: \&quot;rootfs\&quot;,</span><br><span class="hljs-string">        \&quot;path_on_host\&quot;: \&quot;<span class="hljs-variable">$&#123;rootfs_path&#125;</span>\&quot;,</span><br><span class="hljs-string">        \&quot;is_root_device\&quot;: true,</span><br><span class="hljs-string">        \&quot;is_read_only\&quot;: false</span><br><span class="hljs-string">   &#125;&quot;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 不使用API进行配置, 传入配置文件</span><br>./firecracker --api-sock /tmp/firecracker.socket --config-file &lt;path_to_the_configuration_file&gt;<br></code></pre></td></tr></table></figure><blockquote><p>对于DBS而言, 项目最初目标是通过命令行参数进行启动, 而不需要kata的环境, 因此我们可以关注在使用配置文件创建虚拟机的代码逻辑部分, 因此可以关注函数<code>run_without_api</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>  <code>VmResources::from_json</code></p></blockquote><h3 id="122-rootfs和linux-kernel的使用方式"><a class="markdownIt-Anchor" href="#122-rootfs和linux-kernel的使用方式"></a> 1.2.2 rootfs和Linux kernel的使用方式</h3><blockquote><p>要了解rootfs和Linux kernel如何被使用了, 需要从<code>main.rs</code>的<code>run_without_api</code>中, 深入到<code>build_microvm_from_json</code></p></blockquote><ul><li>kernel被以<code>VmmConfig::block_devices</code>的形式传入</li><li>rootfs作为<code>VmmConfig::block_devices</code>配置的一部分进行传入</li><li>至于启动虚拟机等命令, 则可以HTTP API形式, 传递给<code>api_server/src/lib.rs</code>, 接受请求<code>/actions</code>的参数, 并启动配置好的虚拟机</li></ul><blockquote><p>至此, 我们可以带着疑问, 边开始实现我们的项目需求, 边浏览了解firecracker是如何实现的.</p></blockquote><h1 id="2-阶段一-创建命令行前端接口"><a class="markdownIt-Anchor" href="#2-阶段一-创建命令行前端接口"></a> 2. 🔨 阶段一: 创建命令行前端接口</h1><blockquote><p>由于rust编程经验不多, 因此尽可能使用第三方库, 在命令行解析上, 选用<a href="https://github.com/clap-rs/clap">clap</a> (Dual-licensed under <code>Apache 2.0</code> or <code>MIT</code>, 对于DBS而言, 正好可以用<code>Apache 2.0</code>)</p><p><code>clap</code>的使用文档: <a href="https://docs.rs/clap/latest/clap/">https://docs.rs/clap/latest/clap/</a></p></blockquote><h2 id="21-命令行配置项"><a class="markdownIt-Anchor" href="#21-命令行配置项"></a> 2.1 🍨 命令行配置项</h2><blockquote><p>从<a href="https://github.com/kata-containers/kata-containers/tree/runtime-rs">kata-containers</a>的<code>runtime-rs</code>分支中, 可以在<code>dragonball::vm::VmConfigInfo</code>中看到DBS使用的虚拟机配置.</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CpuTopology</span> &#123;<br>    <span class="hljs-comment">/// threads per core to indicate hyperthreading is enabled or not</span><br>    <span class="hljs-keyword">pub</span> threads_per_core: <span class="hljs-type">u8</span>,<br>    <span class="hljs-comment">/// cores per die to guide guest cpu topology init</span><br>    <span class="hljs-keyword">pub</span> cores_per_die: <span class="hljs-type">u8</span>,<br>    <span class="hljs-comment">/// dies per socket to guide guest cpu topology</span><br>    <span class="hljs-keyword">pub</span> dies_per_socket: <span class="hljs-type">u8</span>,<br>    <span class="hljs-comment">/// number of sockets</span><br>    <span class="hljs-keyword">pub</span> sockets: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Clone, Debug, PartialEq)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VmConfigInfo</span> &#123;<br>    <span class="hljs-comment">/// Number of vcpu to start.</span><br>    <span class="hljs-keyword">pub</span> vcpu_count: <span class="hljs-type">u8</span>,<br>    <span class="hljs-comment">/// Max number of vcpu can be added</span><br>    <span class="hljs-keyword">pub</span> max_vcpu_count: <span class="hljs-type">u8</span>,<br>    <span class="hljs-comment">/// cpu power management.</span><br>    <span class="hljs-keyword">pub</span> cpu_pm: <span class="hljs-type">String</span>,<br>    <span class="hljs-comment">/// cpu topology information</span><br>    <span class="hljs-keyword">pub</span> cpu_topology: CpuTopology,<br>    <span class="hljs-comment">/// vpmu support level</span><br>    <span class="hljs-keyword">pub</span> vpmu_feature: <span class="hljs-type">u8</span>,<br><br>    <span class="hljs-comment">/// Memory type that can be either hugetlbfs or shmem, default is shmem</span><br>    <span class="hljs-keyword">pub</span> mem_type: <span class="hljs-type">String</span>,<br>    <span class="hljs-comment">/// Memory file path</span><br>    <span class="hljs-keyword">pub</span> mem_file_path: <span class="hljs-type">String</span>,<br>    <span class="hljs-comment">/// The memory size in MiB.</span><br>    <span class="hljs-keyword">pub</span> mem_size_mib: <span class="hljs-type">usize</span>,<br><br>    <span class="hljs-comment">/// sock path</span><br>    <span class="hljs-keyword">pub</span> serial_path: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>clap</code>定义命令行参数后，具体内容如下:</p><table><thead><tr><th style="text-align:center">arguments</th><th style="text-align:center">required</th><th style="text-align:center">default value</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>rootfs</code></td><td style="text-align:center">true</td><td style="text-align:center">-</td><td style="text-align:center">The path to rootfs image.</td></tr><tr><td style="text-align:center"><code>kernel-path</code></td><td style="text-align:center">true</td><td style="text-align:center">-</td><td style="text-align:center">The path of kernel image (Only uncompressed kernel is supported for Dragonball).</td></tr><tr><td style="text-align:center"><code>log-file</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>&quot;dbs-cli.log&quot;</code></td><td style="text-align:center">The path to log file</td></tr><tr><td style="text-align:center"><code>log-level</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>&quot;Info&quot;</code></td><td style="text-align:center">The logging level.</td></tr><tr><td style="text-align:center"><code>boot-args</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>console=ttyS0 tty0 reboot=k debug panic=1 pci=off root=/dev/vda1</code></td><td style="text-align:center">The boot arguments passed to the kernel.</td></tr><tr><td style="text-align:center"><code>is-root</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>true</code></td><td style="text-align:center">Decide the device to be the root boot device or not.</td></tr><tr><td style="text-align:center"><code>is-read-only</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>false</code></td><td style="text-align:center">The driver opened in read-only or not.</td></tr><tr><td style="text-align:center"><code>vcpu</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">The number of vcpu to start.</td></tr><tr><td style="text-align:center"><code>max-vcpu</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">The max number of vpu can be added.</td></tr><tr><td style="text-align:center"><code>cpu-pm</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>0</code></td><td style="text-align:center">vpmu support level.</td></tr><tr><td style="text-align:center"><code>threads-per-core</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">Threads per core to indicate hyper-threading is enabled or not.</td></tr><tr><td style="text-align:center"><code>cores-per-die</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">Cores per die to guide guest cpu topology init.</td></tr><tr><td style="text-align:center"><code>dies-per-socket</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">Dies per socket to guide guest cpu topology.</td></tr><tr><td style="text-align:center"><code>sockets</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">The number of sockets.</td></tr><tr><td style="text-align:center"><code>mem-type</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>shmem</code></td><td style="text-align:center">Memory type that can be either hugetlbfs or shmem.</td></tr><tr><td style="text-align:center"><code>mem-file</code></td><td style="text-align:center">false</td><td style="text-align:center">``</td><td style="text-align:center">Memory file path.</td></tr><tr><td style="text-align:center"><code>initrd-path</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>None</code></td><td style="text-align:center">The path of initrd.</td></tr></tbody></table><h2 id="22-参数相关的注意事项"><a class="markdownIt-Anchor" href="#22-参数相关的注意事项"></a> 2.2 参数相关的注意事项:</h2><p>整个命令行参数最为关键的三个参数是<code>rootfs</code>, <code>kernel-path</code> 和 <code>boot-args</code>. 由于从命令行终端进入vm的console采用的方式是将ttySx的输出重定向到当前终端的stdout, 因此需要确保kernel支持serial console并且rootfs在构建时需要配置好启动之后能够启动对应终端, 否则将无法进入vm. 对于<code>boot-args</code>, <code>console=xx</code>和<code>root=&quot;dev/vda1&quot;</code> 是根据对应rootfs的设置来的, 因此虽然不是必须给出的参数, 但是需要自行查看是否需要有所修改。</p><h1 id="3-阶段二-项目实现思路及问题解决"><a class="markdownIt-Anchor" href="#3-阶段二-项目实现思路及问题解决"></a> 3. 🔥 阶段二： 项目实现思路及问题解决</h1><h2 id="31-命令行参数"><a class="markdownIt-Anchor" href="#31-命令行参数"></a> 3.1 命令行参数：</h2><p>​根据firecraker和kata-container现有代码，确定启动虚拟机必备参数后，便可直接用<code>clap</code>提供的一些<code>derive</code>来定义命令行参数，参数项见上表，暂无问题出现。</p><h2 id="32-进入vm终端"><a class="markdownIt-Anchor" href="#32-进入vm终端"></a> 3.2 进入vm终端：</h2><p>​基于现有kata-container的一些创建vm、启动vm、创建设备等API，只需进行简单的修改调用即可完成。但是最后在IO上出现问题，具体可以描述为创建vm的标准输入输出终端时，<code>com1</code>未将输出重定向到stdout，导致无法与vm进行交互。</p><p>​解决方法，为<code>com1</code>设置输出流并重定向到<code>stdout</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">device.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">set_output_stream</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(std::io::<span class="hljs-title function_ invoke__">stdout</span>())));<br></code></pre></td></tr></table></figure><h2 id="33-基本原理-serial-console"><a class="markdownIt-Anchor" href="#33-基本原理-serial-console"></a> 3.3 基本原理： <code>serial console</code></h2><ul><li><a href="https://www.kernel.org/doc/html/latest/admin-guide/serial-console.html">Linux Serial Console — The Linux Kernel documentation</a></li><li><a href="https://tldp.org/HOWTO/Serial-HOWTO-10.html">Serial HOWTO: Serial Port Devices /dev/ttyS2, etc. (tldp.org)</a></li></ul><blockquote><p>下图为串口对应终端名以及IO地址</p></blockquote><p><img src="https://s1.ax1x.com/2022/08/29/vfSKR1.png" alt="" /></p><p><code>kata-container</code>在<code>runtime-rs</code>分支下，com2被用来输出日志信息（同时也将dmesg也写入logger了），因此只能使用设备com1连接到对应的终端。</p><blockquote><p><code>console=device,options</code> 用来指定终端的输出，该参数放在kernel的启动参数中。</p><p><code>device</code>可能的值为：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">tty0 <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> foreground virtual console<br>                ttyX <span class="hljs-keyword">for</span> <span class="hljs-keyword">any</span> other virtual console<br>                ttySx <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> serial port<br>                lp0 <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> parallel port<br>                ttyUSB0 <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> USB serial device<br></code></pre></td></tr></table></figure></blockquote><p>在<code>kata-container</code>仓库<code>runtime-rs</code>分支的现有代码下，已经有通过socket进入serial console的代码，但是从命令行将stdio重定向到虚拟机serial console的代码却不能达到正常预期。在通过反复浏览代码，通过<code>3.2</code>中的修改，解决了无法创建stdio console的问题，再加上此前实现的命令行参数解析，整个流程就已经完成了。</p><h1 id="4-项目成果展示"><a class="markdownIt-Anchor" href="#4-项目成果展示"></a> 4. 项目成果展示：</h1><h2 id="41-本地开发仓库"><a class="markdownIt-Anchor" href="#41-本地开发仓库"></a> 4.1 本地开发仓库：</h2><p>仓库地址： <a href="https://github.com/QiliangFan/kata-containers">https://github.com/QiliangFan/kata-containers</a></p><p>分支：<code>runtime-rs</code></p><h2 id="42-pull-request"><a class="markdownIt-Anchor" href="#42-pull-request"></a> 4.2  pull request:</h2><ul><li><p><a href="https://github.com/openanolis/dbs-cli/pull/1">Create VM from command line arguments #1</a></p></li><li><p><a href="https://github.com/kata-containers/kata-containers/pull/5082">dragonball: Fix problem that stdio console cannot connect to stdout #5082</a></p></li></ul><h2 id="43-运行示例与结果截图"><a class="markdownIt-Anchor" href="#43-运行示例与结果截图"></a> 4.3 运行示例与结果截图:</h2><blockquote><p>为了结果易于复现，使用了firecraker项目的kernel和rootfs(方便用户下载， 当然其他支持serial console的内核和rootfs也可以)，如需运行此CLI，可前往<a href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/getting-started.md">firecracker/getting-started.md at main · firecracker-microvm/firecracker (github.com)</a>下载并使用</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./dbs-cli --kernel-path ~/data/build/dbs/firecracker/vmlinux.bin --rootfs ~/data/build/dbs/firecracker/bionic.rootfs.ext4 --boot-args <span class="hljs-string">&quot;console=ttyS0 tty0 reboot=k debug panic=1 pci=off root=/dev/vda&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/27/vRc536.png" alt="进入vm" /></p><p><img src="https://s1.ax1x.com/2022/08/27/vRczgf.png" alt="输入指令" /></p><h2 id="44-可通过命令行配置的参数"><a class="markdownIt-Anchor" href="#44-可通过命令行配置的参数"></a> 4.4 可通过命令行配置的参数：</h2><table><thead><tr><th style="text-align:center">arguments</th><th style="text-align:center">required</th><th style="text-align:center">default value</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><code>rootfs</code></td><td style="text-align:center">true</td><td style="text-align:center">-</td><td style="text-align:center">The path to rootfs image.</td></tr><tr><td style="text-align:center"><code>kernel-path</code></td><td style="text-align:center">true</td><td style="text-align:center">-</td><td style="text-align:center">The path of kernel image (Only uncompressed kernel is supported for Dragonball).</td></tr><tr><td style="text-align:center"><code>log-file</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>&quot;dbs-cli.log&quot;</code></td><td style="text-align:center">The path to log file</td></tr><tr><td style="text-align:center"><code>log-level</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>&quot;Info&quot;</code></td><td style="text-align:center">The logging level.</td></tr><tr><td style="text-align:center"><code>boot-args</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>console=ttyS0 tty0 reboot=k debug panic=1 pci=off root=/dev/vda1</code></td><td style="text-align:center">The boot arguments passed to the kernel.</td></tr><tr><td style="text-align:center"><code>is-root</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>true</code></td><td style="text-align:center">Decide the device to be the root boot device or not.</td></tr><tr><td style="text-align:center"><code>is-read-only</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>false</code></td><td style="text-align:center">The driver opened in read-only or not.</td></tr><tr><td style="text-align:center"><code>vcpu</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">The number of vcpu to start.</td></tr><tr><td style="text-align:center"><code>max-vcpu</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">The max number of vpu can be added.</td></tr><tr><td style="text-align:center"><code>cpu-pm</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>0</code></td><td style="text-align:center">vpmu support level.</td></tr><tr><td style="text-align:center"><code>threads-per-core</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">Threads per core to indicate hyper-threading is enabled or not.</td></tr><tr><td style="text-align:center"><code>cores-per-die</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">Cores per die to guide guest cpu topology init.</td></tr><tr><td style="text-align:center"><code>dies-per-socket</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">Dies per socket to guide guest cpu topology.</td></tr><tr><td style="text-align:center"><code>sockets</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">The number of sockets.</td></tr><tr><td style="text-align:center"><code>mem-type</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>shmem</code></td><td style="text-align:center">Memory type that can be either hugetlbfs or shmem.</td></tr><tr><td style="text-align:center"><code>mem-file</code></td><td style="text-align:center">false</td><td style="text-align:center">``</td><td style="text-align:center">Memory file path.</td></tr><tr><td style="text-align:center"><code>initrd-path</code></td><td style="text-align:center">false</td><td style="text-align:center"><code>None</code></td><td style="text-align:center">The path of initrd.</td></tr></tbody></table><h2 id="45-使用示例"><a class="markdownIt-Anchor" href="#45-使用示例"></a> 4.5 使用示例:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./dbs-cli \<br>  --kernel-path ~/data/build/dbs/vmlinux.bin \<br>  --rootfs ~/data/build/dbs/rootfs.dmg \<br>  --boot-args <span class="hljs-string">&quot;console=ttyS0 tty0 reboot=k debug panic=1 pci=off root=/dev/vda1&quot;</span> ;<br></code></pre></td></tr></table></figure><p>For the rootfs from firecracker:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./dbs-cli \<br>  --kernel-path ~/data/build/dbs/vmlinux.bin \<br>  --rootfs ~/data/build/dbs/bionic.rootfs.ext4 \<br>  --boot-args <span class="hljs-string">&quot;console=ttyS0 tty0 reboot=k debug panic=1 pci=off root=/dev/vda&quot;</span> ;<br></code></pre></td></tr></table></figure><p>For the rootfs build from kata:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./dbs-cli \<br>  --kernel-path ~/data/build/dbs/vmlinux.bin \<br>  --rootfs ~/data/build/dbs/kata-containers.img \<br>  --boot-args <span class="hljs-string">&quot;console=ttyS0 tty0 reboot=k debug panic=1 pci=off root=/dev/vda1&quot;</span> ;<br></code></pre></td></tr></table></figure><p>Set the log level and log file:</p><blockquote><p>The log-level argument is case-insensitive: ErrOR and InFO are valid.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./dbs-cli \<br>  --log-file dbs-cli.log --log-level ERROR \<br>  --kernel-path ~/data/build/dbs/vmlinux.bin \<br>  --rootfs ~/data/build/dbs/kata-containers.img \<br>  --boot-args <span class="hljs-string">&quot;console=ttyS0 tty0 reboot=k debug panic=1 pci=off root=/dev/vda1&quot;</span> ;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;
    &lt;font size=&quot;10&quot;&gt;&lt;bold&gt;使用命令行参数启动微型虚拟机&lt;/bold&gt;&lt;/font&gt;
    &lt;br/&gt;&lt;br/&gt;
&lt;/center&gt;
&lt;h1 id=&quot;1-项目实现方案研究&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    
    <category term="报告" scheme="https://www.torch-fan.site/tags/%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
</feed>
