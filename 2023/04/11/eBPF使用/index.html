<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="default-src 'none'; form-action 'none'; base-uri 'self'; img-src 'self' imagebed.torch-fan.site img1.imgtp.com s1.ax1x.com s1.328888.xyz; script-src 'self' lib.baomitu.com at.alicdn.com utteranc.es 'nonce-1' 'nonce-2' 'nonce-3' 'nonce-4' 'nonce-5' 'nonce-6' 'nonce-7' 'nonce-8' 'nonce-9' 'nonce-10' 'nonce-11' 'nonce-12' 'nonce-13' 'nonce-14'; style-src 'self' 'unsafe-inline' at.alicdn.com lib.baomitu.com; media-src 'self' blob:; worker-src 'self' blob:; object-src 'self'; connect-src 'self'; font-src 'self' lib.baomitu.com at.alicdn.com data:; frame-src 'self' utteranc.es ; "><meta name="theme-color" content="#2f4154"><meta name="author" content="Torch-Fan"><meta name="keywords" content=""><meta name="description" content="1. 准备工作  这一章的主要内容是用eBPF写一个Hellow World程序，因此就需要开始一些简单的环境搭建工作，作为后续深入的准备。  首先为了更好的上手eBPF，我们从BCC(BPF Compiler Collection)入手，这个工具提供了eBPF的Python Binding。 安装方式可以参考仓库中给出的指南，注意，目前只推荐通过源码的方式进行安装。  2. Hello Wor"><title>(二)eBPF的Hello World - Torch-Fan</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.2/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs" nonce="4">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"www.torch-fan.site",root:"/",version:"1.9.0",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Torch-Fan" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Torch-Fan</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="(二)eBPF的Hello World"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-11 19:10" pubdate>2023年4月11日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 91 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">(二)eBPF的Hello World</h1><div class="markdown-body"><h1 id="1-准备工作"><a class="markdownIt-Anchor" href="#1-准备工作"></a> 1. 准备工作</h1><blockquote><p>这一章的主要内容是用eBPF写一个Hellow World程序，因此就需要开始一些简单的环境搭建工作，作为后续深入的准备。</p></blockquote><p>首先为了更好的上手eBPF，我们从<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">BCC(BPF Compiler Collection)</a>入手，这个工具提供了eBPF的Python Binding。</p><p>安装方式可以参考仓库中给出的<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">指南</a>，注意，目前只推荐通过源码的方式进行安装。</p><h1 id="2-hello-world"><a class="markdownIt-Anchor" href="#2-hello-world"></a> 2. Hello World</h1><p>首先，我们知道<code>fork</code>会调用<code>sys_clone</code>这个系统调用，因此我们可以编写如下程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br><span class="hljs-comment"># 这个ebpf程序会绑定在sys_clone这个系统调用上（fork所使用的）</span><br>BPF(text=<span class="hljs-string">&#x27;int kprobe__sys_clone(void *ctx) &#123; bpf_trace_printk(&quot;Hello, World!\\n&quot;); return 0; &#125;&#x27;</span>).trace_print()<br></code></pre></td></tr></table></figure><p><code>kprobe__sys_clone</code>表示绑定内核态函数sys_clone，每当其触发时，就执行<code>kprobe__sys_clone</code>的内容。其中<code>bpf_trace_printk()</code>打印的内核信息会出现在:<code>/sys/kernel/debug/tracing/trace_pipe</code>中。该文件内容的查看需要root权限。</p><p>随后我们可以在命令行执行这个python脚本(注意，我们需要root权限): <code>sudo python3 main.py</code></p><p>但是存在一个问题是：有时我们知道一个用户态程序，不知道其对应的系统调用是什么，却想用kprobe绑定其在内核态函数执行的事件。eBPF提供了相应的辅助函数(helper function): <code>get_syscall_fnname</code>。具体用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Hello World!&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 创建一个待绑定的函数 hello，后面我们会将它绑定到一个内核函数的执行上</span><br>b = BPF(text=program)<br><br><span class="hljs-comment"># 调用helper function获取函数名对应的系统调用</span><br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br><span class="hljs-comment"># 进行kprobe绑定</span><br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment"># 打印eBPF程序的执行情况</span><br>b.trace_print()<br></code></pre></td></tr></table></figure><p>这一个例子中，我们又看到不一样的绑定方式，第一种方式是通过定义一个具有特别名字的用户态程序来实现对相应syscall的自动绑定，第二种方式需要我们主动调用attach函数进行绑定。</p><p>另一方面我们注意到，eBPF程序可以通过一个trace pipe输出相应信息，可以作为最基本的调试目的。但是由于只能输出纯文本，其信息丰富度有限，无法表示结构化数据。特别是当有数量较多的eBPF同时向trace pipe中输出信息，那么信息将变得混乱不堪。</p><h1 id="3-bpf-maps"><a class="markdownIt-Anchor" href="#3-bpf-maps"></a> 3. BPF Maps</h1><p><code>map</code>是一个能够被eBPF程序访问的数据结构，且内核态和用户态下都能访问。<code>map</code>是eBPF有别于其前身的重要变化，但是<code>eBPF maps</code>和<code>BPF maps</code>都有人使用。<code>map</code>主要有两点用途:</p><ol><li>用于在多个eBPF程序之间共享数据</li><li>用于eBPF(运行在内核的那部分代码)与用户态应用程序之间进行通信</li></ol><p>而<code>map</code>典型的使用方式包含以下三点:</p><ol><li>在用户态下编写一些配置信息，以供eBPF程序使用</li><li>某个eBPF程序向其中存储一些状态，然后供另一个eBPF程序使用（或者在将来供同一个eBPF读取，做一些状态恢复的工作）</li><li>eBPF程序可以将一些结果或者指标写进<code>map</code>, 提供给其他用户态应用程序来展示结果。</li></ol><p><code>BPF maps</code>的各种具体类型定义在Linux的<code>uapi/linux/bpf.h</code>中，并且<a target="_blank" rel="noopener" href="https://docs.kernel.org/bpf/maps.html">内核文档</a>中也包含相关的类型信息。通常里面的数据都是使用key-value的形式存储。这一章中，书中介绍了三种类型的<code>maps</code>：<code>hash tables</code>, <code>perf and ring buffers</code>, 和<code>arrays</code>。</p><p>除此以外，还有一些针对特定操作优化的<code>map</code>类型，譬如: <code>first-in-first-out queues</code>, <code>first-in-last-out stacks</code>, <code>least-recently-used data storage</code>, <code>longest-prefix matching</code>, 和<code>Bloom filters</code>(一种专门用来快速判断元素是否存在的数据集)。</p><p>而有一些<code>map</code>类型则具有特定的作用。譬如<code>sockmaps</code>和<code>devmaps</code>保存着关于sockets和network devices的信息，并且被网络相关的eBPF程序用于进行<code>流量重定向(redirect traffic)</code>。<code>program array map</code>存储着一系列被索引的eBPF程序，这个结构用来实现<code>尾调用(tail calls)</code>——一个eBPF程序调用另一个eBPF程序。甚至还有<code>map-of-maps</code>的类型用来实现maps信息的存储。</p><p>当一些<code>map</code>可能同时被多个cpu并发访问时，就涉及到竞态问题。Linux内核版本5.1之后为一些<code>maps</code>支持了自旋锁(spin lock)，这一点将之后再补充。</p><h2 id="31-hash-table-map"><a class="markdownIt-Anchor" href="#31-hash-table-map"></a> 3.1 Hash Table Map</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_HASH(counter_table);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    u64 uid;</span><br><span class="hljs-string">    u64 counter = 0;</span><br><span class="hljs-string">    u64 *p;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    uid = bpf_get_current_uid_gid() &amp; 0xffffffff;</span><br><span class="hljs-string">    p = counter_table.lookup(&amp;uid);</span><br><span class="hljs-string">    if (p != 0) &#123;</span><br><span class="hljs-string">        counter = *p;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    counter++;</span><br><span class="hljs-string">    counter_table.update(&amp;uid, &amp;counter);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>bpf = BPF(text=program)<br>syscall = bpf.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>bpf.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><ol><li><p><code>BPF_HASH()</code>是BCC定义的宏，用来定义一个<code>hash table map</code>, 具体可见: <a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/bcc/+/refs/heads/android10-c2f2-s1-release/docs/reference_guide.md#2_bpf_hash">https://android.googlesource.com/platform/external/bcc/+/refs/heads/android10-c2f2-s1-release/docs/reference_guide.md#2_bpf_hash</a></p></li><li><p><code>bpf_get_current_uid_gid</code>是一个eBPF的helper function用来获取触发kprobe事件对应的进程的user ID。<font color="red"><strong>返回值的低32位是UID，高32位是UID</strong></font>，因此<code>bpf_get_current_uid_gid() &amp; 0xffffffff</code>作用是将低32位的uid取出来。</p></li><li><p><code>counter_table.lookup(&amp;uid)</code>是用来在hash table中查询一个键对应的值，返回值是对应value的地址。这里可能会想：<code>&amp;uid</code>并非正确的C语言用法，<font color="red"><strong>这是因为一个eBPF源码送到compiler进行编译之前，会对源程序进行修正并重写为正确的C语言代码，随后才会送进编译器中</strong></font>。<code>p=counter_table.lookup(&amp;uid)</code>也是同理，虽然看起来是错误的，但是编译时会自动修正。<font color="cyan">虽然为eBPF hash table map设置的键值类型是u64（默认类型），但是传参时为了高效都是以指针的形式传入——尽管传入的是函数局部变量，但是这点错误并不影响编译，反而是eBPF程序的推荐写法</font></p></li><li><p><code>counter_table.update(&amp;uid, &amp;counter);</code>是用来更新对应uid的计数信息。</p></li></ol><h3 id="311-在用户空间程序中访问ebpf-maps数据结构"><a class="markdownIt-Anchor" href="#311-在用户空间程序中访问ebpf-maps数据结构"></a> 3.1.1 在用户空间程序中访问eBPF maps数据结构：</h3><blockquote><p>上面我们定义了名为<code>counter_table</code>的<code>hash table map</code>。如果想在Python代码中获取对应数据结构的内容，可以这样：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        sleep(<span class="hljs-number">2</span>)<br>        s = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> bpf[<span class="hljs-string">&quot;counter_table&quot;</span>].items():<br>            s += <span class="hljs-string">f&quot;ID <span class="hljs-subst">&#123;k.value&#125;</span>: <span class="hljs-subst">&#123;v.value&#125;</span>\t&quot;</span><br>        <span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>bpf[“counter_table”]中存储的是键值对，键和值类型是一个对象(<code>c_ulong</code>)，如果要从中获取值只需要<code>k.value</code>即可转为传统的标量。要注意的是，以上面那种方式创建的<code>hash table map</code>并不能持久化，每次重启程序原先的状态就不存在了。并且这种map也不能在eBPF程序之间共享。</p><h3 id="312-持久化并共享ebpf-maps"><a class="markdownIt-Anchor" href="#312-持久化并共享ebpf-maps"></a> 3.1.2 持久化并共享eBPF maps:</h3><blockquote><p>此处可参阅文档：<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#pinned-maps">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#pinned-maps</a></p><p><code>BPF_TABLE_PINNED(_table_type, _key_type, _leaf_type, _name, _max_entries, &quot;/sys/fs/bpf/xyz&quot;)</code>: 如果对应的map存在就获取，不存在则创建一个。<code>/sys/fs/bpf</code>是一个特别的bpffs。</p><p><font color="red">注意</font>，请务必确保bcc是通过源码编译安装的，否则无法确保是最新的~</p></blockquote><p>首先我们创建一个<code>pinned map</code>, 以供其他eBPF程序访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bcc<br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_TABLE_PINNED(&quot;hash&quot;, u64, u64, counter_table, 1024, &quot;/sys/fs/bpf/map&quot;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    u64 uid;</span><br><span class="hljs-string">    u64 counter = 0;</span><br><span class="hljs-string">    u64 *p;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    uid = bpf_get_current_uid_gid() &amp; 0xffffffff;</span><br><span class="hljs-string">    p = counter_table.lookup(&amp;uid);</span><br><span class="hljs-string">    if (p != 0) &#123;</span><br><span class="hljs-string">        counter = *p;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    counter++;</span><br><span class="hljs-string">    counter_table.update(&amp;uid, &amp;counter);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>bpf = BPF(text=program)<br>syscall = bpf.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>bpf.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-built_in">print</span>(bpf.get_table(<span class="hljs-string">&quot;counter_table&quot;</span>))<br></code></pre></td></tr></table></figure><p>接着在另一个程序中编写如下内容，即可获取相应<code>pinned map</code>，注意这个map即使在第一个程序退出之后仍然存在，且始终可以被任意eBPF访问到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_TABLE_PINNED(&quot;hash&quot;, u64, u64, counter_table, 1024, &quot;/sys/fs/bpf/map&quot;);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void* ctx) &#123;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>bpf = BPF(text=program)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> bpf.get_table(<span class="hljs-string">&quot;counter_table&quot;</span>).items():<br>    <span class="hljs-built_in">print</span>(k.value, v.value)<br></code></pre></td></tr></table></figure><h2 id="32-perf-and-ring-buffer-maps"><a class="markdownIt-Anchor" href="#32-perf-and-ring-buffer-maps"></a> 3.2 Perf and Ring Buffer Maps</h2><blockquote><p>上面的例子中使用hash table map来在内核和用户态空间中交换数据，但是Linux内核支持使用perf buffers和其变种BPF ring buffers来完成这个数据交换的过程。注意，<code>BPF ring buffers</code>在<font color="red">Linux kernel 5.8</font>之后才支持，但是相比<code>BPF perf buffers</code>更受欢迎。关于如何使用<code>BPF ring buffers</code>来进行数据交换，将在后面章节详细给出例子。</p></blockquote><h3 id="321-ring-buffer"><a class="markdownIt-Anchor" href="#321-ring-buffer"></a> 3.2.1 Ring Buffer</h3><blockquote><p>Ring Buffer的机制其实细节还是非常多的，由于关注的是eBPF这里只能给出最粗略和感性的认知。</p></blockquote><p>  在eBPF中，Ring Buffer的概念并没有什么特别的。Ring Buffer就是一小块内存，逻辑上以&quot;环(ring)&quot;进行组织，包含两个指针: <code>写指针</code>和<code>读指针</code>。</p><p>  当进行数据写入时，无论当前写指针指向的内容是什么，会直接写入指定长度（长度信息包含在数据对象的header中）的数据，写指针会偏移到写入数据结尾的下一个位置，等待下一次写入。</p><p>  当进行数据读取时，也是直接从当前读指针处获取指定长度的数据，然后将读指针偏移指定长度（<font color="cyan">方向和写指针一致</font>）</p><p>  注意：</p><ol><li>当读指针和写指针重叠时，意味着&quot;没有&quot;数据需要去读了。</li><li>如果一个写操作，可能使写指针超过读指针(意味着写指针写满一&quot;圈&quot;数据了至少), 那么该写操作将被抛弃并且<code>drop counter</code>会自增1. <code>drop counter</code>用来记录自上一次成功读取数据后，是否有数据丢失。(<font color="red">注意：当发生数据覆盖时究竟是抛弃要写入的数据还是允许覆盖，这并不是一概而论的，有的场景中就比较宽松。</font>)</li><li>如果读操作和写操作的速率始终保持一致，那么就能使用ring buffer读取相当长的数据(并不存在数据丢失问题，写多少读多少)</li></ol><p><img src="ring_buffer.png" srcset="/img/loading.gif" lazyload alt="Ring Buffer"></p><h3 id="322-定义perf-buffer"><a class="markdownIt-Anchor" href="#322-定义perf-buffer"></a> 3.2.2 定义Perf Buffer:</h3><p>第一个程序将用来对Perf Buffer进行写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python">// 定义一个名为`output`的Perf Buffer Map<br>BPF_PERF_OUTPUT(output);<br><br>// 定义一个struct用来传送数据<br>struct data_t &#123;<br>    <span class="hljs-built_in">int</span> pid;<br>    <span class="hljs-built_in">int</span> uid;<br>    char command[<span class="hljs-number">16</span>];<br>    char message[<span class="hljs-number">12</span>];<br>&#125;;<br><br><span class="hljs-built_in">int</span> hello(void *ctx) &#123;<br>    struct data_t data = &#123;&#125;;<br>    char message[<span class="hljs-number">12</span>] = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br>    // tgid对应线程而言就是其所属进程的pid，对进程而言等价于pid<br>    data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="hljs-number">32</span>;<br>    data.uid = bpf_get_current_uid_gid() &amp; <span class="hljs-number">0xfffffff</span>;<br><br>    // 获取进程名字<br>    bpf_get_current_comm(&amp;data.command, sizeof(data.command));<br>    // 为了安全，内核内存的读取必须使用bpf_probe_read_kernel进行;<br>    bpf_probe_read_kernel(&amp;data.message, sizeof(data.message), message);<br><br>    // `ctx`是kprobes或kretprobes提供的;<br>    // `per_submit`会将自定义的data提交到user space中(最终会触发`bpf_perf_event_output`)<br>    output.perf_submit(ctx, &amp;data, sizeof(data));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>bpf = BPF(text=program)<br>syscall = bpf.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>bpf.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_event</span>(<span class="hljs-params">cpu, data, size</span>):<br>    <span class="hljs-comment"># 这是一种便捷的方式对传入的data对象进行解析(转为python对象)，具体可见：https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#2-open_perf_buffer </span><br>    data = b[<span class="hljs-string">&quot;output&quot;</span>].event(data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;data.pid&#125;</span> <span class="hljs-subst">&#123;data.uid&#125;</span> <span class="hljs-subst">&#123;data.command.decode()&#125;</span> <span class="hljs-subst">&#123;data.message.decode()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># BCC进行了封装，可以通过b[&quot;output&quot;]获取对应的Perf Buffer</span><br><span class="hljs-comment"># 为Perf Buffer的读取绑定一个回调函数对读取的数据进行处理:</span><br>b[<span class="hljs-string">&quot;output&quot;</span>].open_perf_buffer(print_event)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 对Perf Buffer的写入事件进行监听，一旦有数据写入就进行读取；触发回调函数`print_event`</span><br>    b.perf_buffer_poll()<br><br><span class="hljs-comment"># While True:</span><br><span class="hljs-comment">#   try:</span><br><span class="hljs-comment">#       b.perf_buffer_poll()</span><br><span class="hljs-comment">#   except KeyboardInterrupt:</span><br><span class="hljs-comment">#       exit()</span><br></code></pre></td></tr></table></figure><p>  注意，<code>Perf Buffer</code>也不是共享和持久的。如果要持久也得用pinned map。这里<code>hello</code>函数的参数是kprobes或者kretprobes提供的，并且还可以调用一些helper function，但<font color="pink"><strong>能够使用哪些上下文信息和能够调用哪些helper function取决于程序的类型和触发程序的事件是什么</strong></font>，在《Learning eBPF》的第七章，对这些进行了介绍。</p><h2 id="33-function-calls"><a class="markdownIt-Anchor" href="#33-function-calls"></a> 3.3 Function Calls</h2><p>  原本在eBPF程序中只能调用helper function，如果想要调用其他函数就必须将自定义函数声明为内联:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx, <span class="hljs-type">int</span> val)</span></span>;<br></code></pre></td></tr></table></figure><p>  内联函数和普通函数在汇编上的区别就是没有额外的跳跃指令，内联函数的函数体会在被调用的地方被原地扩展。但是<font color="red"><strong>从Linux内核版本4.16和LLVM 6.0之后</strong></font>，eBPF中只能使用内联函数的约束就被废除了。但是BCC仍然不支持“BPF subprograms”，仅支持内联函数。</p><h2 id="34-tail-calls"><a class="markdownIt-Anchor" href="#34-tail-calls"></a> 3.4 Tail Calls</h2><blockquote><p><a target="_blank" rel="noopener" href="https://ebpf.io/">ebpf.io</a>中描述了: <code>tail calls can call and execute another eBPF program and replace the execution context, similar to how the execve() system call operates for regular process.</code> 简单来说，<font color="red"><strong>当tail call完成时，不会返回到调用者的上下文环境中</strong></font>。</p></blockquote><blockquote><p>Tail call并非eBPF编程中所独有的。tail call的通用目的是为了避免当函数递归调用时，栈帧无限地增加(这会导致栈溢出)。具体而言，可以重新编排函数代码，使得递归调用函数后，没有任何其他需要干的内容——即递归调用就是函数体的最后一行代码。这样，<code>tail call</code>允许一系列的函数调用不会增长栈的大小。毕竟，当递归调用时，上一个栈帧的函数体不再被需要了，可以被优化掉。在eBPF中，栈帧大小仅有512B。</p></blockquote><p>  Tail call通过helper function: <code>bpf_tail_call()</code>来使用，其函数签名如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">bpf_tail_call</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctx, <span class="hljs-keyword">struct</span> bpf_map *prog_array_map, u32 index)</span></span>;<br></code></pre></td></tr></table></figure><p>  参数含义如下:</p><ul><li><code>ctx</code>用来将当前eBPF程序的上下文传递给被调用的eBPF程序</li><li><code>prog_array_map</code>是一个eBPF map，类型为<code>BPF_MAP_TYPE_PROG_ARRAY</code>，包含了一系列的<em>文件描述符</em>，每个文件描述符都表示一个eBPF程序。</li><li><code>index</code>表示<code>prog_array_map</code>中哪个eBPF程序应该被调用。</li></ul><p>  这里存在两种情况：</p><ol><li>如果<code>bpf_tail_call</code>执行成功，对应的eBPF程序将会执行并替换当前栈帧(当前eBPF的函数体就不再被执行了)</li><li>如果<code>bpf_tail_call</code>执行失败，当前eBPF程序的函数体会继续执行</li></ol><p>下面是一个例子:</p><blockquote><p><code>sys_enter</code> tracepoint和kprobe都是一个触点，每当一个系统调用被执行完时，<code>sys_enter</code>这个tracepoint就会被触发。只需要将一个函数绑定到tracepoint上，每次tracepoint被触发时，该函数会被执行。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-keyword">import</span> ctypes <span class="hljs-keyword">as</span> ct<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">// 注册一个`BPF_MAP_TYPE_PROG_ARRAY`类型的bpf map</span><br><span class="hljs-string">BPF_PROG_ARRAY(syscall, 300);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(struct bpf_raw_tracepoint_args *ctx) &#123;</span><br><span class="hljs-string">    int opcode = ctx-&gt;args[1];</span><br><span class="hljs-string">    // 编译时会重写为: `bpf_tail_call(ctx, program_array_map, index)`</span><br><span class="hljs-string">    syscall.call(ctx, opcode);</span><br><span class="hljs-string">    // 除非上面的tail call失败, 否则下面的语句将不会执行</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Another syscall: %d&quot;, opcode);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_execve(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Executing a program&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_timer(struct bpf_raw_tracepoint *ctx) &#123;</span><br><span class="hljs-string">    if (ctx-&gt;args[1] == 222) &#123;</span><br><span class="hljs-string">        bpf_trace_printk(&quot;Creating a timer&quot;);</span><br><span class="hljs-string">    &#125; else if (ctx-&gt;args[1] == 226) &#123;</span><br><span class="hljs-string">        bpf_trace_printk(&quot;Deleting a timer&quot;);</span><br><span class="hljs-string">    &#125; else &#123;</span><br><span class="hljs-string">        bpf_trace_printk(&quot;Some other timer operation&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int ignore_opcode(void *ctx) &#123;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program)<br>b.attach_raw_tracepoint(tp=<span class="hljs-string">&quot;sys_enter&quot;</span>, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br>ignore_fn = b.load_func(<span class="hljs-string">&quot;ignore_opcode&quot;</span>, BPF.RAW_TRACEPOINT)<br>exec_fn = b.load_func(<span class="hljs-string">&quot;hello_exec&quot;</span>, BPF.RAW_TRACEPOINT)<br>timer_fn = b.load_func(<span class="hljs-string">&quot;hello_timer&quot;</span>, BPF.RAW_TRACEPOINT)<br><br>prog_array = b.get_table(<span class="hljs-string">&quot;syscall&quot;</span>)<br>prog_array[ct.c_int(<span class="hljs-number">59</span>)] = ct.c_int(exec_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">222</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">226</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">21</span>)] = ct.c_int(ignore_fn.fd)<br></code></pre></td></tr></table></figure><p>有几点注意事项:</p><ol><li><code>b.load_func(&quot;ignore_opcode&quot;, BPF.RAW_TRACEPOINT)</code>中，<code>load_func</code>的第一个参数需要是一个eBPF program；第二个参数可以是<code>BPF.RAW_TRACEPOINT</code>、<code>BPF.KPROBE</code>等其他值，具体是什么，要看tail call的&quot;父亲&quot;是什么，如果ebpf程序绑定的是一个tracepoint，那么就需要指定为<code>BPF.RAW_TRACEPOINT</code>，如果ebpf程序绑定的是一个kprobe，就需要指定为<code>BPF.KPROBE</code>.</li><li>上面<code>hello</code>和<code>ignore_opcode</code>的参数都定义为<code>void* ctx</code>，但由于其<code>父亲</code>的上下文来自tracepoint，因此具体的指针类型也是可知的，完全可以声明为: <code>struct bpf_raw_tracepoint *ctx</code>. 如果在kprobe/uprobe下，其参数类型就应该是<code>struct pt_regs *ctx</code>.</li></ol><blockquote><p><code>pt_regs</code> is at the high end of kernel stack, is mainly used for saving user registers in user-kernel mode switching.</p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="category-chain-item">计算机基础</a> <span>></span> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a> <span>></span> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/" class="category-chain-item">Linux</a> <span>></span> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/eBPF/" class="category-chain-item">eBPF</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>(二)eBPF的Hello World</div><div>https://www.torch-fan.site/2023/04/11/eBPF使用/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Torch-Fan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年4月11日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2023年4月27日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/04/13/Linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95/" title="Linux 进程调试"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux 进程调试</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/04/11/eBPF/" title="(一)什么是eBPF?为什么eBPF非常重要?"><span class="hidden-mobile">(一)什么是eBPF?为什么eBPF非常重要?</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><script type="text/javascript" nonce="3">Fluid.utils.loadComments("#comments",function(){var t="github-light",e="github-dark",i="dark"===document.documentElement.getAttribute("data-user-color-scheme")?e:t;(t=(window.UtterancesThemeLight=t,window.UtterancesThemeDark=e,document.createElement("script"))).setAttribute("src","https://utteranc.es/client.js"),t.setAttribute("repo","QiliangFan/qiliangfan.github.io"),t.setAttribute("issue-term","title"),t.setAttribute("label","BlogComment"),t.setAttribute("theme",i),t.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(t)})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script nonce="5">NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script nonce="6">!function(t){var e=Fluid.plugins.typing;(t=t.getElementById("subtitle"))&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script nonce="12">Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length)&&o.css("visibility","visible")})</script><script nonce="8">!function(){var n,i=CONFIG.code_language.enable&&CONFIG.code_language.default,t=CONFIG.copy_btn;(i||t)&&(n="",n+='<div class="code-widget">LANG</div>',jQuery(".markdown-body pre").each(function(){var e,a=jQuery(this);0<a.find("code.mermaid").length||0<a.find("span.line").length||(e="",i&&(e=CONFIG.code_language.default,0<a[0].children.length&&2<=a[0].children[0].classList.length&&a.children().hasClass("hljs")?e=a[0].children[0].classList[1]:a[0].getAttribute("data-language")?e=a[0].getAttribute("data-language"):a.parent().hasClass("sourceCode")&&0<a[0].children.length&&2<=a[0].children[0].classList.length?(e=a[0].children[0].classList[1],a.parent().addClass("code-wrapper")):a.parent().hasClass("markdown-body")&&0===a[0].classList.length&&a.wrap('<div class="code-wrapper"></div>'),e=e.toUpperCase().replace("NONE",CONFIG.code_language.default)),a.append(n.replace("LANG",e).replace('code-widget">',(e=a[0],(0<=Fluid.utils.getBackgroundLightness(e)?"code-widget-light":"code-widget-dark")+(t?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),t&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,n=0;n<a.length;n++)if("CODE"===a[n].tagName)return a[n]}}).on("success",function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout(function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")},2e3)})}))}))}()</script><script nonce="10">Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o,n=[];for(o of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))n.push(".markdown-body > "+o.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))})</script><script nonce="11">Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script nonce="14">Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>